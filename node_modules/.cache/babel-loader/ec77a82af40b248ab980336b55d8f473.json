{"ast":null,"code":"function e(e) {\n  for (var r = 2166136261, t = 0, n = e.length; n > t; ++t) r = (r ^= e.charCodeAt(t)) + (r << 1) + (r << 4) + (r << 7) + (r << 8) + (r << 24);\n\n  return (r >>> 0).toString(36);\n}\n\nfunction r(e, r) {\n  var t,\n      n = {};\n  return o => (t = n[o]) ? t : (t = r(o.replace(g, \"$1\").replace(m, \"{\")), n[o] = t = e || isNaN(t[0]) ? t : \"_\" + t);\n}\n\nfunction t() {}\n\nfunction n(e) {\n  void 0 === e && (e = {});\n  var {\n    key: r = \"ui\",\n    nonce: t,\n    speedy: n,\n    stylisPlugins: o,\n    prefix: i = 1,\n    container: u = \"undefined\" != typeof document ? document.head : void 0\n  } = e,\n      c = new y({\n    prefix: i\n  });\n  n = null == n ? 1 : n;\n  var f = new Set(),\n      l = new Map(),\n      d = new Map(),\n      v = a({\n    key: r,\n    container: u,\n    nonce: t,\n    speedy: n\n  });\n\n  if (\"undefined\" != typeof document) {\n    for (var h, p, g = document.querySelectorAll('style[data-cache=\"' + r + '\"]'), m = 0, k = f.add.bind(f); m < g.length; m++) null !== (h = (p = g[m]).getAttribute(\"data-dash\")) && (h.split(\" \").forEach(k), u && p.parentNode !== u && u.appendChild(p));\n\n    c.use(o)(s);\n  }\n\n  var x = function (e, r, t, n) {\n    f.has(e) || (f.add(e), b.x = void 0 === n ? v : n, c(r, t));\n  };\n\n  return \"undefined\" == typeof document && (x = function (e, r, t, n) {\n    f.has(e) || (f.add(e), b.x = void 0 === n ? v : n, l.set(e, c(r, t)));\n  }), {\n    key: r,\n    sheet: v,\n    sheets: {\n      add(e) {\n        var r = d.get(e) || {\n          n: 0,\n          s: a(v)\n        };\n        return d.set(e, r), r.n++, r.s;\n      },\n\n      delete(e) {\n        var r = d.get(e);\n        return r ? (1 === r.n && (d.delete(e), r.s.flush()), --r.n) : -1;\n      },\n\n      keys: d.keys.bind(d)\n    },\n    stylis: c,\n    insert: x,\n    inserted: f,\n    cache: l\n  };\n}\n\nfunction o(e) {\n  return e.parentNode.removeChild(e);\n}\n\nfunction a(e) {\n  var {\n    key: r,\n    container: t,\n    nonce: n,\n    speedy: a = 0\n  } = e,\n      i = [],\n      s = 0;\n  return {\n    key: r,\n    nonce: n,\n    container: t,\n    speedy: a,\n\n    insert(e) {\n      if (s % (a ? 65e3 : 1) == 0) {\n        var o = document.createElement(\"style\");\n        o.setAttribute(\"data-dash\", r), n && o.setAttribute(\"nonce\", n), o.textContent = \"\", t && t.insertBefore(o, i.length ? i[i.length - 1].nextSibling : null), i.push(o);\n      }\n\n      var u = i[i.length - 1];\n\n      if (a) {\n        var c = u.sheet,\n            f = 0;\n        if (!c) for (var {\n          styleSheets: l\n        } = document; f < l.length; f++) if (l[f].ownerNode === u) {\n          c = l[f];\n          break;\n        }\n\n        try {\n          var d = 105 === e.charCodeAt(1) && 64 === e.charCodeAt(0);\n          c.insertRule(e, d ? 0 : c.cssRules.length);\n        } catch (e) {}\n      } else u.textContent += e;\n\n      s++;\n    },\n\n    flush() {\n      i.forEach(o), i.length = 0, s = 0;\n    }\n\n  };\n}\n\nfunction i(e) {\n  e && b.x.insert(e + \"}\");\n}\n\nfunction s(e, r, t, n, o, a, s, u, c, f) {\n  if (1 === e) {\n    if (64 === r.charCodeAt(0)) return b.x.insert(r + \";\"), \"\";\n  } else if (2 === e) {\n    if (0 === u) return r + \"/*|*/\";\n  } else {\n    if (3 === e) return 102 === u || 112 === u ? (b.x.insert(t[0] + r), \"\") : r + (0 === f ? \"/*|*/\" : \"\");\n    -2 === e && r.split(\"/*|*/}\").forEach(i);\n  }\n}\n\nfunction u(e) {\n  return e();\n}\n\nfunction c(o) {\n  void 0 === o && (o = {});\n  var a = o.dash || n(),\n      {\n    key: i,\n    insert: s,\n    sheets: c\n  } = a,\n      h = {},\n      p = {},\n      y = r(i, o.hash || e),\n      g = {\n    variants(e) {\n      function r() {\n        var e = t.apply(null, arguments);\n        if (!e) return \"\";\n        var r = y(e),\n            n = i + \"-\" + r;\n        return s(r, \".\" + n, e), n;\n      }\n\n      function t() {\n        var e = arguments,\n            r = e.length;\n        if (1 === r && \"object\" != typeof e[0]) return a + (o[e[0]] || \"\");\n\n        if (r > 0) {\n          for (var t = a, n = 0; r > n; n++) {\n            var i = e[n];\n            if (\"object\" != typeof i) t += o[i] || \"\";else if (null !== i) for (var s in i) i[s] && (t += o[s] || \"\");\n          }\n\n          return t;\n        }\n\n        return a;\n      }\n\n      var n,\n          o = {};\n\n      for (n in e) o[n] = f(e[n], p);\n\n      var a = o.default || \"\";\n      return r.styles = e, r.css = t, r;\n    },\n\n    one() {\n      var e = f(l(arguments), p),\n          r = y(e),\n          t = i + \"-\" + r,\n          n = function (n) {\n        return n || void 0 === n ? (s(r, \".\" + t, e), t) : \"\";\n      };\n\n      return n.css = function (r) {\n        return r || void 0 === r ? e : \"\";\n      }, n;\n    },\n\n    cls() {\n      var e = f(l(arguments), p),\n          r = y(e),\n          t = i + \"-\" + r;\n      return s(r, \".\" + t, e), t;\n    },\n\n    lazy(e) {\n      function r(r) {\n        if (void 0 === r) return \"\";\n        var n = \"object\" == typeof r ? JSON.stringify(r) : r,\n            o = t.get(n);\n        return void 0 === o && (o = f(e(r), p), t.set(n, o)), o;\n      }\n\n      var t = new Map(),\n          n = function (e) {\n        var t = r(e);\n        if (!t) return \"\";\n        var n = y(t),\n            o = i + \"-\" + n;\n        return s(n, \".\" + o, t), o;\n      };\n\n      return n.css = r, n;\n    },\n\n    join() {\n      var e = \"\".concat(...Array.prototype.slice.call(arguments)),\n          r = y(e),\n          t = i + \"-\" + r;\n      return s(r, \".\" + t, e), t;\n    },\n\n    keyframes() {\n      var e = f(l(arguments), p),\n          r = y(e),\n          t = i + \"-\" + r;\n      return s(r, \"\", \"@keyframes \" + t + \"{\" + e + \"}\", c.add(r)), t;\n    },\n\n    insertGlobal() {\n      var e = f(l(arguments), p);\n      if (!e) return t;\n      var r = y(e);\n      return s(r, \"\", e, c.add(r)), function () {\n        !c.delete(r) && a.inserted.delete(r);\n      };\n    },\n\n    insertTokens(e, r) {\n      void 0 === r && (r = \":root\");\n\n      var {\n        css: n,\n        vars: a\n      } = function e(r, t, n) {\n        void 0 === n && (n = []);\n        var o = {},\n            a = \"\";\n\n        for (var i in r) {\n          var s = r[i];\n\n          if (\"object\" == typeof s) {\n            var u = e(s, t, n.concat(i));\n            o[i] = u.vars, a += u.css;\n          } else {\n            var c = d(n.length > 0 ? n.join(\"-\") + \"-\" + i : i).replace(A, \"-\");\n            o[i] = \"var(\" + (c = \"--\" + (1 == t || t && !t[c] ? j(c) : c)) + \")\", a += c + \":\" + s + \";\";\n          }\n        }\n\n        return {\n          vars: o,\n          css: a\n        };\n      }(e, o.mangleTokens);\n\n      return n ? (v(p, a), g.insertGlobal(r + \"{\" + n + \"}\")) : t;\n    },\n\n    insertThemes(e) {\n      var r = [];\n\n      for (var t in e) r.push(g.insertTokens(h[t] = void 0 === h[t] ? e[t] : v(h[t], e[t]), \".\" + g.theme(t)));\n\n      return function () {\n        r.forEach(u);\n      };\n    },\n\n    theme: e => i + \"-\" + e + \"-theme\",\n    dash: a,\n    hash: y,\n    tokens: p\n  };\n  return Object.defineProperty(g, \"tokens\", {\n    get: () => p,\n    configurable: 0\n  }), g.insertTokens(o.tokens || k), g.insertThemes(o.themes || k), g;\n}\n\nfunction f(e, r) {\n  var t = \"function\" == typeof e ? e(r) : e;\n  return \"object\" == typeof t && null !== t ? function e(r) {\n    var t = \"\";\n\n    for (var n in r) {\n      var o = r[n];\n\n      if (\"object\" != typeof o) {\n        var a = 45 === n.charCodeAt(1);\n        t += (a ? n : d(n)) + \":\" + (\"number\" != typeof o || p[n] || 0 === o || a ? o : o + \"px\") + \";\";\n      } else t += n + \"{\" + e(o) + \"}\";\n    }\n\n    return t;\n  }(t) : t || \"\";\n}\n\nfunction l(e) {\n  var r = e[0];\n  return Array.isArray(r) ? r.reduce((r, t, n) => r + t + (e[n + 1] || \"\"), \"\") : r;\n}\n\nfunction d(e) {\n  var r;\n  return null !== (r = C[e]) && void 0 !== r ? r : C[e] = e.replace(x, \"-$&\").toLowerCase();\n}\n\nfunction v(e, r) {\n  for (var t in r) {\n    var n = r[t];\n    e[t] = \"object\" == typeof n ? v(e[t] || {}, n) : n;\n  }\n\n  return e;\n}\n\nfunction h(e) {\n  return \"var(--\" + e.replace(/\\./g, \"-\").replace(x, \"-$&\").toLowerCase() + \")\";\n}\n\nimport p from \"@dash-ui/unitless\";\nimport y from \"@dash-ui/stylis\";\nvar g = /(^|[:;,{}\\s])\\s+|$/g,\n    m = / +{/g,\n    b = {\n  x: {\n    insert: t\n  }\n},\n    k = {},\n    x = /[A-Z]|^ms/g,\n    A = /[^\\w-]/g,\n    C = {},\n    j = r(\"\", e),\n    w = c();\nexport { f as compileStyles, n as createDash, c as createStyles, e as hash, h as pathToToken, a as styleSheet, w as styles };","map":{"version":3,"mappings":"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","names":["hash","string","out","i","len","length","charCodeAt","toString","safeHash","key","hashFn","value","hashCache","replace","minL","minR","isNaN","noop","createDash","options","nonce","speedy","stylisPlugins","prefix","container","document","head","stylis","Stylis","inserted","Set","cache","Map","sheetsCache","sheet","styleSheet","attr","node","nodes","querySelectorAll","insert","add","bind","getAttribute","split","forEach","parentNode","appendChild","use","ruleSheet","selector","styles","has","Sheet","x","set","sheets","name","sheetRef","get","n","s","delete","flush","keys","tag","removeChild","tags","size","rule","createElement","setAttribute","textContent","insertBefore","nextSibling","push","styleSheets","ownerNode","isImportRule","insertRule","cssRules","e","block","context","content","selectors","parents","line","column","ns","depth","at","RULE_DELIMITER","createStyles","dash","themes","tokens","fnv1aHash","variants","styleMap","style","css_","css","apply","arguments","className","args","numArgs","defaultStyles","compiledStyleMap","nextStyles","arg","styleKey","compileStyles","default","one","compileLiterals","callback","createClassName","createCss","cls","lazy","lazyFn","JSON","stringify","lazyStyle","join","concat","Array","prototype","slice","call","keyframes","animationName","insertGlobal","insertTokens","nextTokens","vars","serializeTokens","mangle","names","result","cssCase","cssDisallowedRe","mangled","mangleTokens","mergeTokens","insertThemes","nextThemes","theme","Object","defineProperty","configurable","emptyObj","stringifyStyleObject","object","isCustom","unitless","literals","isArray","reduce","curr","next","caseCache","cssCaseRe","toLowerCase","target","source","pathToToken","path"],"sources":["C:\\Users\\LENOVO\\Desktop\\reactapp-serenity\\node_modules\\@dash-ui\\styles\\src\\utils.ts","C:\\Users\\LENOVO\\Desktop\\reactapp-serenity\\node_modules\\@dash-ui\\styles\\src\\create-dash.ts","C:\\Users\\LENOVO\\Desktop\\reactapp-serenity\\node_modules\\@dash-ui\\styles\\src\\create-styles.ts"],"sourcesContent":["/**\n * An FNV-1a hashing algorithm with a 32-bit offset basis. FNV-1a hashes are designed\n * to be fast while maintaining a low collision rate. The high dispersion rate makes\n * them well-suited for hashing nearly identical strings.\n *\n * @param string - A string you want to hash\n */\nexport function hash(string: string): string {\n  // 32-bit offset basis\n  let out = 2166136261;\n  let i = 0;\n  let len = string.length;\n\n  for (; i < len; ++i)\n    out =\n      (out ^= string.charCodeAt(i)) +\n      (out << 1) +\n      (out << 4) +\n      (out << 7) +\n      (out << 8) +\n      (out << 24);\n\n  return (out >>> 0).toString(36);\n}\n\nconst minL = /(^|[:;,{}\\s])\\s+|$/g;\nconst minR = / +{/g;\n\nexport function safeHash(\n  key: string,\n  hashFn: typeof hash\n): (string: string) => string {\n  const hashCache: Record<string, string> = {};\n  let value: string | undefined;\n  return (string: string): string => {\n    if ((value = hashCache[string])) return value;\n    value = hashFn(string.replace(minL, \"$1\").replace(minR, \"{\"));\n    // allows class names to start with numbers\n    return (hashCache[string] = value =\n      !key && !isNaN(value[0] as any) ? \"_\" + value : value);\n  };\n}\n\nexport function noop(): void {}\n","import Stylis from \"@dash-ui/stylis\";\nimport type { Context, Plugable, Plugin } from \"@dash-ui/stylis\";\nimport { noop } from \"./utils\";\n\n/**\n * Dash is a tiny, performant CSS-in-JS style rule sheet manager similar to Emotion.\n *\n * @param options - Configuration options\n */\nexport function createDash(options: CreateDashOptions = {}): Dash {\n  let {\n    key = \"ui\",\n    nonce,\n    speedy,\n    stylisPlugins,\n    prefix = true,\n    container = typeof document !== \"undefined\" ? document.head : void 0,\n  } = options;\n  const stylis = new Stylis({ prefix });\n  speedy =\n    speedy === void 0 || speedy === null\n      ? !(\n          typeof process !== \"undefined\" &&\n          process.env.NODE_ENV !== \"production\"\n        )\n      : speedy;\n  const inserted: Dash[\"inserted\"] = new Set<string>();\n  const cache: Dash[\"cache\"] = new Map();\n  const sheetsCache = new Map<string, DashSheet>();\n  const sheet = styleSheet({\n    key,\n    container,\n    nonce,\n    speedy,\n  });\n\n  if (typeof document !== \"undefined\") {\n    let nodes = document.querySelectorAll('style[data-cache=\"' + key + '\"]');\n    let i = 0;\n    let attr;\n    let node;\n    const insert = inserted.add.bind(inserted);\n\n    for (; i < nodes.length; i++) {\n      /* istanbul ignore next */\n      if ((attr = (node = nodes[i]).getAttribute(`data-dash`)) === null)\n        continue;\n      attr.split(\" \").forEach(insert);\n\n      container && node.parentNode !== container && container.appendChild(node);\n    }\n\n    stylis.use(stylisPlugins)(ruleSheet as Plugin);\n  }\n\n  /* istanbul ignore next */\n  if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n    const commentStart = /\\/\\*/g;\n    const commentEnd = /\\*\\//g;\n\n    stylis.use((context, content) => {\n      if (context === -1) {\n        while (commentStart.test(content)) {\n          commentEnd.lastIndex = commentStart.lastIndex;\n\n          /* istanbul ignore next */\n          if (commentEnd.test(content)) {\n            commentStart.lastIndex = commentEnd.lastIndex;\n            continue;\n          }\n\n          throw new Error(\n            'Your styles have an unterminated comment (\"/*\" without ' +\n              'corresponding \"*/\").'\n          );\n        }\n\n        commentStart.lastIndex = 0;\n      }\n    });\n  }\n\n  let insert: Dash[\"insert\"] = function (key, selector, styles, styleSheet) {\n    if (inserted.has(key)) return;\n    inserted.add(key);\n    Sheet.x = styleSheet === void 0 ? sheet : styleSheet;\n    stylis(selector, styles);\n  };\n\n  if (typeof document === \"undefined\") {\n    insert = function (key, selector, styles, styleSheet) {\n      if (inserted.has(key)) return;\n      inserted.add(key);\n      Sheet.x = styleSheet === void 0 ? sheet : styleSheet;\n      cache.set(key, stylis(selector, styles));\n    };\n  }\n\n  return {\n    key,\n    sheet,\n    sheets: {\n      add(name) {\n        const sheetRef = sheetsCache.get(name) || {\n          n: 0,\n          s: styleSheet(sheet),\n        };\n        sheetsCache.set(name, sheetRef);\n        sheetRef.n++;\n        return sheetRef.s;\n      },\n      delete(name) {\n        const sheetRef = sheetsCache.get(name);\n        if (!sheetRef) return -1;\n        if (sheetRef.n === 1) {\n          sheetsCache.delete(name);\n          sheetRef.s.flush();\n        }\n        return --sheetRef.n;\n      },\n      keys: sheetsCache.keys.bind(sheetsCache),\n    },\n    stylis,\n    insert,\n    inserted,\n    cache,\n  };\n}\n\nexport interface CreateDashOptions {\n  /**\n   * Keys in sheets used to associate `<style>` tags with this\n   * specific `dash` instances via the `dash-cache` property.\n   *\n   * @default \"ui\"\n   */\n  readonly key?: string;\n  /**\n   * For security policies. A nonce is an arbitrary number that can be used just\n   * once in a cryptographic communication.\n   */\n  readonly nonce?: string;\n  /**\n   * An array of stylis plugins\n   * See: https://www.npmjs.com/package/stylis\n   */\n  readonly stylisPlugins?: Plugable[];\n  /**\n   * Turns on/off vendor prefixing. When a boolean, all prefixes will be\n   * turned on/off. Use a function to define your own prefixes for a given key/value.\n   *\n   * @default true\n   */\n  readonly prefix?:\n    | boolean\n    | ((key: string, value: any, context: any) => boolean);\n  /**\n   * This is the container that `<style>` tags will be injected into\n   * when style rules are inserted.\n   *\n   * @default document.head\n   */\n  readonly container?: HTMLElement;\n  /**\n   * Uses speedy mode for `<style>` tag insertion. It's the fastest way\n   * to insert new style rules, but will make styles uneditable in some browsers.\n   *\n   * @default false\n   */\n  readonly speedy?: boolean;\n}\n\nexport type Dash = {\n  /**\n   * The sheet key\n   */\n  readonly key: string;\n  /**\n   * The default style sheet used by this instance of Dash\n   */\n  readonly sheet: DashStyleSheet;\n  /**\n   * Used for tracking external sheets. You can safely add/delete new\n   * custom sheets using this. Those sheets can be used in the `insert()`\n   * method. The primary reason you'd want to use this is so that you can\n   * create independently flushable styles/sheets.\n   */\n  readonly sheets: DashSheets;\n  /**\n   * The instance of Stylis used by this Dash instance\n   */\n  readonly stylis: typeof Stylis;\n  /**\n   * A cache of Stylis rules saved by their keys. This is only used\n   * on the server for generating CSS files and strings from the keys\n   * used in the cache.\n   */\n  readonly cache: Map<string, string>;\n  /**\n   * A function for inserting style rules into the document and cache.\n   *\n   * @param key - The unique key of the rule. This is used for caching.\n   * @param selector - The CSS selector to insert the rule under. Omit this\n   *   when inserting a global style.\n   * @param styles - The rules string you'd like to insert into the document or cache.\n   * @param styleSheet - The style sheet to insert a rule into, for example `dash.sheet`.\n   */\n  insert(\n    key: string,\n    selector: string,\n    styles: string,\n    styleSheet?: DashStyleSheet\n  ): void;\n  /**\n   * An insertion cache. This tracks which keys have already been inserted into\n   * the DOM to prevent duplicates.\n   */\n  readonly inserted: Set<string>;\n};\n\n/**\n * A stylesheet cache that tracks references to the keys in it.\n * When there are no more references to a sheet, it will be flushed\n * from the DOM.\n */\nexport interface DashSheets {\n  /**\n   * Creates a new stylesheet if it doesn't exist and returns it.\n   *\n   * @param key - The unique key of the style sheet\n   */\n  add(key: string): DashStyleSheet;\n  /**\n   * Deletes the stylesheet from the sheets cache and flushes the\n   * `<style>` tag from the DOM if this is is the last reference to\n   * the key.\n   *\n   * @param key - The key to the sheet\n   */\n  delete(key: string): number;\n  /**\n   * Returns an iterator containing all of the keys in the cache.\n   */\n  keys(): ReturnType<Map<string, DashSheet>[\"keys\"]>;\n}\n\ninterface DashSheet {\n  /**\n   * The number of references to the sheet\n   */\n  n: number;\n  /**\n   * A dash style sheet.\n   */\n  s: DashStyleSheet;\n}\n\n//\n// Stylesheet\nexport function styleSheet(options: DashStyleSheetOptions): DashStyleSheet {\n  // Based off emotion and glamor's StyleSheet\n  const { key, container, nonce, speedy = false } = options;\n  const tags: HTMLStyleElement[] = [];\n  let size = 0;\n\n  return {\n    // include all keys so it the object can be cloned via styleSheet(sheet)\n    key,\n    nonce,\n    container,\n    speedy,\n    insert(rule) {\n      // the max length is how many rules we have per style tag, it's 65000 in\n      // speedy mode it's 1 in dev because we insert source maps that map a\n      // single rule to a location and you can only have one source map per\n      // style tag\n      if (size % (speedy ? 65000 : 1) === 0) {\n        const tag = document.createElement(\"style\");\n        tag.setAttribute(`data-dash`, key);\n        if (nonce) tag.setAttribute(\"nonce\", nonce);\n        tag.textContent = \"\";\n        container &&\n          container.insertBefore(\n            tag,\n            !tags.length ? null : tags[tags.length - 1].nextSibling\n          );\n        tags.push(tag);\n      }\n\n      const tag = tags[tags.length - 1];\n\n      if (!speedy) {\n        tag.textContent += rule;\n      } else {\n        let sheet: StyleSheet | CSSStyleSheet | null = tag.sheet;\n        let i = 0;\n        /* istanbul ignore next */\n        if (!sheet) {\n          // this weirdness brought to you by firefox\n          const { styleSheets } = document;\n          for (; i < styleSheets.length; i++)\n            if (styleSheets[i].ownerNode === tag) {\n              sheet = styleSheets[i];\n              break;\n            }\n        }\n\n        /* istanbul ignore next */\n        try {\n          // this is a really hot path\n          // we check the second character first because having \"i\"\n          // as the second character will happen less often than\n          // having \"@\" as the first character\n          const isImportRule =\n            rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64;\n          // this is the ultrafast version, works across browsers\n          // the big drawback is that the css won't be editable in devtools\n          (sheet as CSSStyleSheet).insertRule(\n            rule,\n            // we need to insert @import rules before anything else\n            // otherwise there will be an error\n            // technically this means that the @import rules will\n            // _usually_(not always since there could be multiple style tags)\n            // be the first ones in prod and generally later in dev\n            // this shouldn't really matter in the real world though\n            // @import is generally only used for font faces from google fonts\n            // and etc. so while this could be technically correct then it\n            // would be slower and larger for a tiny bit of correctness that\n            // won't matter in the real world\n            isImportRule ? 0 : (sheet as CSSStyleSheet).cssRules.length\n          );\n        } catch (e) {\n          if (\n            typeof process !== \"undefined\" &&\n            process.env.NODE_ENV !== \"production\"\n          ) {\n            console.warn(\n              'There was a problem inserting the following rule: \"' +\n                rule +\n                '\"',\n              e\n            );\n          }\n        }\n      }\n\n      size++;\n    },\n    flush() {\n      tags.forEach((tag) => (tag.parentNode as HTMLElement).removeChild(tag));\n      tags.length = 0;\n      size = 0;\n    },\n  };\n}\n\nexport interface DashStyleSheetOptions {\n  /**\n   * Keys in sheets used to associate style sheets with\n   * specific `dash` instances\n   */\n  readonly key: string;\n  /**\n   * The element to insert `<style>` tags into. For example,\n   * `document.head`.\n   */\n  readonly container?: HTMLElement;\n  /**\n   * For security policies. A nonce is an arbitrary number that can be used just\n   * once in a cryptographic communication.\n   */\n  readonly nonce?: string;\n  /**\n   * Uses speedy mode for `<style>` tag insertion. It's the fastest way\n   * to insert new style rules, but will make styles uneditable in some browsers.\n   *\n   * @default false\n   */\n  readonly speedy?: boolean;\n}\n\nexport interface DashStyleSheet {\n  /**\n   * The sheet key\n   */\n  readonly key: string;\n  /**\n   * The sheet nonce\n   */\n  readonly nonce?: string;\n  /**\n   * The sheet container\n   */\n  readonly container?: HTMLElement;\n  /**\n   * `true` if speedy mode is turned on\n   */\n  readonly speedy: boolean;\n  /**\n   * Inserts a style rule into your sheet\n   *\n   * @param rule - A style rule to insert into the sheet\n   */\n  insert(rule: string): void;\n  /**\n   * Removes all style rules from the sheet.\n   */\n  flush(): void;\n}\n\n//\n// Stylis plugins\nconst RULE_DELIMITER = \"/*|*/\";\nconst RULE_NEEDLE = RULE_DELIMITER + \"}\";\n\nfunction ruleSheet(\n  // https://github.com/thysultan/stylis.js/tree/master/plugins/rule-sheet\n  context: Context,\n  content: any,\n  selectors: string[],\n  parents: string[],\n  line: number,\n  column: number,\n  length: number,\n  ns: number,\n  depth: number,\n  at: number\n): string | undefined {\n  // property\n  if (context === 1) {\n    if (content.charCodeAt(0) === 64) {\n      // @import\n      Sheet.x.insert(content + \";\");\n      return \"\";\n    }\n  }\n  // selector\n  else if (context === 2) {\n    if (ns === 0) return content + RULE_DELIMITER;\n  }\n  // at-rule\n  else if (context === 3) {\n    // @font-face, @page\n    if (ns === 102 || ns === 112) {\n      Sheet.x.insert(selectors[0] + content);\n      return \"\";\n    } else {\n      /* istanbul ignore next */\n      return content + (at === 0 ? RULE_DELIMITER : \"\");\n    }\n  } else if (context === -2) {\n    content.split(RULE_NEEDLE).forEach((block: string) => {\n      block && Sheet.x.insert(block + \"}\");\n    });\n  }\n}\n\nconst Sheet: {\n  x: {\n    insert(rule: string): void;\n  };\n} = {\n  x: {\n    insert: noop,\n  },\n};\n","import unitless from \"@dash-ui/unitless\";\nimport type {\n  HtmlAttributes as CSSHTMLAttributes,\n  PropertiesFallback as CSSProperties,\n  Pseudos as CSSPseudos,\n  SvgAttributes as CSSSvgAttributes,\n} from \"csstype\";\nimport type { JsonValue, PartialDeep, Primitive, ValueOf } from \"type-fest\";\nimport { createDash } from \"./create-dash\";\nimport type { Dash } from \"./create-dash\";\nimport { hash as fnv1aHash, noop, safeHash } from \"./utils\";\n\n/**\n * A factory function that returns a new `styles` instance with\n * your custom configuration options.\n *\n * @param options - Configuration options\n */\nexport function createStyles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(options: CreateStylesOptions<Tokens, Themes> = {}): Styles<Tokens, Themes> {\n  const dash = options.dash || createDash();\n  const { key, insert, sheets } = dash;\n  const themes = {} as Themes;\n  const tokens = {} as TokensUnion<Tokens, Themes>;\n  const hash = safeHash(key, options.hash || fnv1aHash);\n\n  let label: (args: any[]) => string;\n  // explicit here on purpose so it's not in every test\n  /* istanbul ignore next */\n  if (\n    typeof process !== \"undefined\" &&\n    process.env.NODE_ENV === \"development\"\n  ) {\n    label = function (args) {\n      // add helpful labels to the name in development\n      return [...args]\n        .reduce((curr, arg) => {\n          if (typeof arg === \"string\") {\n            curr += \"-\" + arg;\n          } else if (typeof arg === \"object\") {\n            const keys = Object.keys(arg).filter(\n              (k) => typeof arg[k] === \"number\" || arg[k]\n            );\n\n            if (keys.length) {\n              curr += \"-\" + keys.join(\"-\");\n            }\n          }\n\n          return curr;\n        }, \"\")\n        .replace(/[^\\w-]/g, \"-\");\n    };\n  }\n\n  const styles: Styles<Tokens, Themes> = {\n    variants<Variants extends string | number>(\n      styleMap: StyleMap<Variants, Tokens, Themes>\n    ): Style<Variants, Tokens, Themes> {\n      const compiledStyleMap: Record<string | number, string> = {};\n      let styleKey: keyof typeof styleMap;\n      /* istanbul ignore next */\n      for (styleKey in styleMap)\n        compiledStyleMap[styleKey] = compileStyles(styleMap[styleKey], tokens);\n\n      const defaultStyles = compiledStyleMap.default || \"\";\n\n      // style('text', {})\n      function style(): string {\n        // eslint-disable-next-line prefer-spread\n        const css_ = css.apply(null, arguments as any);\n        if (!css_) return \"\";\n        let name = hash(css_);\n        /* istanbul ignore next */\n        if (label) name += label(arguments as any);\n        const className = key + \"-\" + name;\n        insert(name, \".\" + className, css_);\n        return className;\n      }\n\n      function css(): string {\n        const args = arguments as unknown as StyleArguments<Variants>;\n        const numArgs = args.length;\n\n        if (numArgs === 1 && typeof args[0] !== \"object\") {\n          return defaultStyles + (compiledStyleMap[args[0] as any] || \"\");\n        } else if (numArgs > 0) {\n          let nextStyles = defaultStyles;\n\n          for (let i = 0; i < numArgs; i++) {\n            let arg = args[i];\n            if (typeof arg !== \"object\") {\n              nextStyles += compiledStyleMap[arg as any] || \"\";\n            } else if (arg !== null) {\n              for (const key in arg)\n                if (arg[key]) nextStyles += compiledStyleMap[key] || \"\";\n            }\n          }\n\n          return nextStyles;\n        }\n\n        return defaultStyles;\n      }\n\n      style.styles = styleMap;\n      style.css = css;\n      return style;\n    },\n    one() {\n      const one = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(one);\n      const className = key + \"-\" + name;\n      const callback: StylesOne = function (createClassName) {\n        if (!createClassName && createClassName !== void 0) return \"\";\n        insert(name, \".\" + className, one);\n        return className;\n      };\n      callback.css = function (createCss) {\n        return !createCss && createCss !== void 0 ? \"\" : one;\n      };\n      return callback;\n    },\n    cls() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(css);\n      const className = key + \"-\" + name;\n      insert(name, \".\" + className, css);\n      return className;\n    },\n    lazy<Value extends LazyValue>(\n      lazyFn: (\n        value: Value\n      ) => string | StyleCallback<Tokens, Themes> | StyleObject\n    ): StylesLazy<Value> {\n      const cache = new Map<string | Value, string>();\n\n      function css(value?: Value): string {\n        if (value === void 0) return \"\";\n        const key = typeof value === \"object\" ? JSON.stringify(value) : value;\n        let css = cache.get(key);\n\n        if (css === void 0) {\n          css = compileStyles<Tokens, Themes>(lazyFn(value), tokens);\n          cache.set(key, css);\n        }\n\n        return css;\n      }\n\n      const lazyStyle: StylesLazy<Value> = function (value?: Value) {\n        const css_ = css(value);\n        if (!css_) return \"\";\n        const name = hash(css_);\n        const className = key + \"-\" + name;\n        insert(name, \".\" + className, css_);\n        return className;\n      };\n      lazyStyle.css = css;\n      return lazyStyle;\n    },\n    join() {\n      const css = \"\".concat(...Array.prototype.slice.call(arguments));\n      const name = hash(css);\n      const className = key + \"-\" + name;\n      insert(name, \".\" + className, css);\n      return className;\n    },\n    keyframes() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(css);\n      const animationName = key + \"-\" + name;\n      // Adding to a cached sheet here rather than the default sheet because\n      // we want this to persist between `clearCache()` calls.\n      insert(\n        name,\n        \"\",\n        \"@keyframes \" + animationName + \"{\" + css + \"}\",\n        sheets.add(name)\n      );\n      return animationName;\n    },\n    insertGlobal() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n\n      if (!css) return noop;\n      const name = hash(css);\n      insert(name, \"\", css, sheets.add(name));\n      return function () {\n        !sheets.delete(name) && dash.inserted.delete(name);\n      };\n    },\n    insertTokens(nextTokens, selector = \":root\") {\n      const { css, vars } = serializeTokens(nextTokens, options.mangleTokens);\n      if (!css) return noop;\n      mergeTokens<Tokens, Themes>(tokens, vars);\n      return styles.insertGlobal(selector + \"{\" + css + \"}\");\n    },\n    insertThemes(nextThemes) {\n      const flush: (() => void)[] = [];\n\n      for (const name in nextThemes) {\n        flush.push(\n          styles.insertTokens(\n            // God the types here are f'ing stupid. Someone should feel free to fix this.\n            (themes[name as Extract<keyof Themes, string>] =\n              themes[name as Extract<keyof Themes, string>] === void 0\n                ? nextThemes[name]\n                : mergeTokens<any>(\n                    themes[name as Extract<keyof Themes, string>],\n                    nextThemes[name] as any\n                  )),\n            \".\" + styles.theme(name as Extract<keyof Themes, string>)\n          )\n        );\n      }\n\n      return function () {\n        flush.forEach((e) => e());\n      };\n    },\n    theme(theme) {\n      return key + \"-\" + theme + \"-theme\";\n    },\n    dash,\n    hash,\n    tokens,\n  };\n\n  Object.defineProperty(styles, \"tokens\", {\n    get() {\n      return tokens;\n    },\n    configurable: false,\n  });\n  styles.insertTokens(options.tokens || emptyObj);\n  styles.insertThemes(options.themes || emptyObj);\n  return typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\"\n    ? Object.freeze(styles)\n    : styles;\n}\n\nconst emptyObj: any = {};\n\nexport interface CreateStylesOptions<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> {\n  /**\n   * An instance of dash created by the `createDash()` factory\n   *\n   * @default createDash()\n   */\n  dash?: Dash;\n  /**\n   * Inserts CSS tokens into the DOM and makes them available for use in\n   * style callbacks. The name of the CSS tokens is automatically generated\n   * based upon the depth of the mapping i.e. `foo.bar.baz` -> `--foo-bar-baz`.\n   *\n   * @example\n   * const styles = createStyles({\n   *   tokens: {\n   *     color: {\n   *       // var(--color-light-red)\n   *       lightRed: '#c17'\n   *     }\n   *   }\n   * })\n   *\n   * const bgRed = styles.one(({color}) => ({\n   *   backgroundColor: color.lightRed\n   * }))\n   *\n   * const Component = () => <div className={bgRed()} />\n   */\n  readonly tokens?: Tokens;\n  /**\n   * A mapping of theme name/CSS variable pairs.\n   *\n   * This Creates a CSS variable-based theme by defining tokens within a\n   * class name selector matching the theme name. Apart from that it works\n   * the same way `tokens` does.\n   *\n   * @example\n   * const styles = createStyles({\n   *   themes: {\n   *     // .ui-light\n   *     light: {\n   *       // var(--background-color)\n   *       backgroundColor: '#fff'\n   *     },\n   *     // .ui-dark\n   *     dark: {\n   *       // var(--background-color)\n   *       backgroundColor: '#000'\n   *     }\n   *   }\n   * })\n   *\n   * // CSS tokens in the 'dark' theme take precedence in this component\n   * const App = () => <div className={styles.theme('dark)}/>\n   */\n  readonly themes?: Themes;\n  /**\n   * When `true` this will mangle CSS variable names. You can also\n   * provide an object with `{key: boolean}` pairs of reserved keys\n   * which will not be mangled.\n   *\n   * @example\n   * const styles = createStyles({\n   *   // All CSS tokens will be mangled in production\n   *   mangleTokens: process.env.NODE_ENV === 'production'\n   * })\n   * @example\n   * const styles = createStyles({\n   *   mangleTokens: {\n   *     // --vh will not be mangled\n   *     vh: true\n   *   }\n   * })\n   */\n  readonly mangleTokens?: boolean | Record<string, boolean>;\n  /**\n   * Use your own hash function for creating selector names. By default\n   * Dash uses an fnv1a hashing algorithm.\n   */\n  readonly hash?: typeof fnv1aHash;\n}\n\n/**\n * Utility methods that accomplish everything you need to scale an application\n * using CSS-in-JS.\n */\nexport interface Styles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> {\n  /**\n   * `styles.variants()` is a function for composing styles in a\n   * deterministic way. It returns a function which when called will insert\n   * your styles into the DOM and create a unique class name.\n   *\n   * @param styleMap - A style name/value mapping\n   * @example\n   * const bg = styles({\n   *   // Define styles using an object\n   *   blue: {\n   *     backgroundColor: 'blue'\n   *   },\n   *   // Access stored CSS tokens when a callback is provided as\n   *   // the value\n   *   red: ({colors}) => `\n   *     background-color: ${colors.red};\n   *   `,\n   *   // Define styles using a string\n   *   green: `\n   *     background-color: green;\n   *   `\n   * })\n   *\n   * // This component will have a \"red\" background\n   * const Component = () => <div className={bg('blue', 'red')}/>\n   *\n   * // This component will have a \"blue\" background\n   * const Component = () => <div className={bg('red', 'blue')}/>\n   *\n   * // This component will have a \"green\" background\n   * const Component = () => <div className={bg({red: true, green: true})}/>\n   */\n  variants<Variants extends string | number>(\n    styleMap: StyleMap<Variants, Tokens, Themes>\n  ): Style<Variants, Tokens, Themes>;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback,\n   * and returns a function. That function inserts the style into a `<style>` tag and\n   * returns a class name when called.\n   *\n   * @example\n   * const row = styles.one`\n   *   display: flex;\n   *   flex-wrap: nowrap;\n   * `\n   * const Row = props => <div {...props} className={row()}/>>\n   * // This will not insert the styles if `isRow` is `false`\n   * const RowSometimes = ({isRow = false}) => <div className={row(isRow)}/>>\n   */\n  one(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleObject\n      | StyleCallback<Tokens, Themes>,\n    ...placeholders: string[]\n  ): StylesOne;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Calling this will immediately insert the CSS into the DOM and return a unique\n   * class name for the styles. This is a shortcut for `styles.one('display: flex;')()`.\n   *\n   * @example\n   * const Component = () => <div className={styles.cls`display: flex;`}/>\n   */\n  cls(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleObject\n      | StyleCallback<Tokens, Themes>,\n    ...placeholders: string[]\n  ): string;\n  /**\n   * A function that uses lazy evalution to create styles with indeterminate values.\n   * Calling this will immediately insert the CSS into the DOM and return a unique\n   * class name for the styles.\n   *\n   * @example\n   * const lazyWidth = styles.lazy((width) => ({\n   *   width\n   * }))\n   * const Component = ({width = 200}) => <div className={lazyWidth(width)}/>>\n   */\n  lazy<Value extends LazyValue>(\n    lazyFn: (\n      value: Value\n    ) => string | StyleCallback<Tokens, Themes> | StyleObject\n  ): StylesLazy<Value>;\n  /**\n   * A function that joins CSS strings, inserts them into the DOM right away, and returns a class name.\n   *\n   * @example\n   * const Component = () => <div\n   *   className={styles.join(\n   *     button.css('primary'),\n   *     transition.css('fade'),\n   *     'display: block;'\n   *   )}\n   * />\n   */\n  join(...css: string[]): string;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Using this will immediately insert a global `@keyframes` defintion into the DOM and\n   * return the name of the keyframes instance.\n   *\n   * @example\n   * const fadeIn = styles.keyframes`\n   *   from {\n   *     opacity: 0;\n   *   }\n   *\n   *   to {\n   *     opactity: 1\n   *   }\n   * `\n   */\n  keyframes(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleCallback<Tokens, Themes>\n      | StyleObject,\n    ...placeholders: string[]\n  ): string;\n  /**\n   * A function that returns the generated class name for a given theme when\n   * using `insertThemes()` to create CSS variable-based themes.\n   *\n   * @param name - The name of the theme\n   * @example\n   * styles.insertThemes({\n   *  dark: {\n   *    color: {\n   *      background: '#000'\n   *    }\n   *  }\n   * })\n   *\n   * const Component = () => <div className={styles.theme('dark')}/>\n   */\n  theme(name: keyof Themes): string;\n  /**\n   * Inserts CSS tokens into the DOM and makes them available for use in\n   * style callbacks. The name of the CSS tokens is automatically generated\n   * based upon the depth of the mapping i.e. `foo.bar.baz` -> `--foo-bar-baz`.\n   * This function returns a function that will flush the styles inserted by\n   * `insertTokens()` when it is called.\n   *\n   * @param tokens - A map of CSS variable name/value pairs\n   * @param selector - Including a selector will only make these CSS variable\n   *   definitions take effect within the selector, e.g. a class name or ID. By\n   *   default the selector is `\":root\"`.\n   * @example\n   * // Inserts CSS tokens into the document `:root`\n   * styles.insertTokens({\n   *   color: {\n   *     // var(--color-indigo)\n   *     indigo: '#5c6ac4',\n   *     // var(--color-blue)\n   *     blue: '#007ace',\n   *     // var(--color-red)\n   *     red: '#de3618',\n   *   }\n   * })\n   *\n   * // Overrides the above when they are used within a `.dark` selector\n   * const flushTokens = styles.insertTokens(\n   *   {\n   *     color: {\n   *       // var(--color-indigo)\n   *       indigo: '#5c6ac4',\n   *       // var(--color-blue)\n   *       blue: '#007ace',\n   *       // var(--color-red)\n   *       red: '#de3618',\n   *     }\n   *   },\n   *   '.dark'\n   * )\n   */\n  insertTokens(tokens: PartialDeep<Tokens>, selector?: string): () => void;\n  /**\n   * Creates a CSS variable-based theme by defining tokens within a\n   * class name selector matching the theme name. Apart from that it works\n   * the same way `insertTokens()` does. This function returns a function\n   * that will flush the styles inserted by `insertTokens()` when it is called.\n   *\n   * @param themes - A mapping of theme name/CSS variable pairs.\n   * @example\n   * const flushThemes = styles.insertThemes({\n   *   // .ui-light\n   *   light: {\n   *     // var(--background-color)\n   *     backgroundColor: '#fff'\n   *   },\n   *   // .ui-dark\n   *   dark: {\n   *     // var(--background-color)\n   *     backgroundColor: '#000'\n   *   }\n   * })\n   *\n   * // \"dark\" css tokens will take precedence within this component\n   * const Component = () => <div className={styles.theme('dark)}/>\n   */\n  insertThemes(\n    themes: PartialDeep<{\n      [Name in keyof Themes]: Themes[Name];\n    }>\n  ): () => void;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Using this will immediately insert styles into the DOM relative to the root document.\n   * This function returns a function that will flush the styles inserted by\n   * `insertGlobal()` when it is called.\n   *\n   * @example\n   * const flushGlobal = styles.insertGlobal(({color}) => `\n   *   body {\n   *     background-color: ${color.primaryBg};\n   *   }\n   * `)\n   */\n  insertGlobal(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleCallback<Tokens, Themes>\n      | StyleObject,\n    ...placeholders: string[]\n  ): () => void;\n  /**\n   * The CSS tokens currently defined in the instance\n   */\n  tokens: TokensUnion<Tokens, Themes>;\n  /**\n   * A hashing function for creating unique selector names\n   *\n   * @param string - The string you'd like to hash\n   */\n  hash(string: string): string;\n  /**\n   * The instance of underlying the Dash cache used by this instance. This was\n   * automatically created by `createDash()` when `createStyles()` was called.\n   * Dash controls the caching, style sheets, auto-prefixing, and DOM insertion\n   * that happens in the `styles` instance.\n   */\n  dash: Dash;\n}\n\n/**\n * A function that inserts styles from the style map into the DOM when called\n * with those style names selected.\n *\n * @param args - A series of style names or style name/boolean maps which\n *  select the styles from the style map you want to compose into a singular\n *  deterministic style and class name.\n * @example\n * const style = styles.variants({\n *   block: 'display: block',\n *   w100: 'width: 100px;',\n *   h100: 'height: 100px',\n * })\n *\n * // display: block; height: 100px; width: 100px;\n * const Component = () => <div className={style('block', 'h100', 'w100')}/>\n */\nexport type Style<\n  Variants extends string | number,\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = {\n  (...args: StyleArguments<Variants>): string;\n  /**\n   * A function that returns the raw, CSS string for a given\n   * name in the style map.\n   *\n   * @param names - A series of style names or style name/boolean maps which\n   *  select the styles from the style map you want to compose into a singular\n   *  CSS string.\n   * @example\n   * const style = styles.variants({\n   *   block: 'display: block',\n   *   w100: 'width: 100px;',\n   *   h100: 'height: 100px',\n   * })\n   *\n   * const someOtherStyle = styles.variants({\n   *   // display: block; height: 100px; width: 100px;\n   *   default: style.css('block', 'h100', 'w100')\n   * })\n   */\n  css(...names: StyleArguments<Variants>): string;\n  /**\n   * The style map that this `style()` instance was instantiated with.\n   */\n  styles: StyleMap<Variants, Tokens, Themes>;\n};\n\n/**\n * A function that inserts styles into the DOM when called without\n * a falsy value. If the first argument is falsy, the styles will\n * not be inserted and a class name will not be returned.\n */\nexport type StylesOne = {\n  (createClassName?: boolean | number | string | null): string;\n  /**\n   * A method that returns a CSS string if the first argument is not falsy.\n   */\n  css(createCss?: boolean | number | string | null): string;\n};\n\nexport type StyleMap<\n  Variants extends string | number,\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = {\n  [Name in Variants | \"default\"]?: StyleValue<Tokens, Themes>;\n};\n\nexport type StyleArguments<Variants extends string | number> = (\n  | Variants\n  | {\n      [Name in Variants]?: boolean | null | undefined | string | number;\n    }\n  | Exclude<Falsy, 0 | \"\">\n)[];\n\nexport type StyleValue<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = string | StyleCallback<Tokens, Themes> | StyleObject;\n\ntype KnownStyles = {\n  [property in keyof CSSProperties]?:\n    | CSSProperties[property]\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | (string & {})\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | (number & {});\n};\n\ntype PseudoStyles = {\n  [property in CSSPseudos | CSSHTMLAttributes | CSSSvgAttributes]?: StyleObject;\n};\n\ntype SelectorStyles = {\n  [property: string]:\n    | string\n    | number\n    | KnownStyles\n    | PseudoStyles\n    | SelectorStyles;\n};\n\nexport type StyleObject = KnownStyles & PseudoStyles & SelectorStyles;\n\nexport type StyleCallback<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = (tokens: TokensUnion<Tokens, Themes>) => StyleObject | string;\n\nexport type LazyValue = JsonValue;\n\n/**\n * A function that inserts indeterminate styles based on the value\n * into the DOM when called.\n *\n * @param value - A JSON serializable value to create indeterminate\n *   styles from\n */\nexport type StylesLazy<Value extends LazyValue> = {\n  (value?: Value): string;\n  /**\n   * A method that returns indeterminate CSS strings based on the value\n   * when called.\n   *\n   * @param value - A JSON serializable value to create indeterminate\n   *   styles from\n   */\n  css(value?: Value): string;\n};\n\n//\n// Utils\nexport type Falsy = false | null | undefined | \"\" | 0;\n\n/**\n * A utility function that will compile style objects and callbacks into CSS strings.\n *\n * @param styles - A style callback, object, or string\n * @param tokens - A map of CSS tokens for style callbacks\n */\nexport function compileStyles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(\n  styles: StyleValue<Tokens, Themes> | Falsy,\n  tokens: TokensUnion<Tokens, Themes>\n): string {\n  const value = typeof styles === \"function\" ? styles(tokens) : styles;\n  return typeof value === \"object\" && value !== null\n    ? stringifyStyleObject(value)\n    : // TypeScript w/o \"strict\": true throws here\n      ((value || \"\") as string);\n}\n\nfunction stringifyStyleObject(object: StyleObject): string {\n  let string = \"\";\n\n  for (const key in object) {\n    const value = object[key];\n\n    if (typeof value !== \"object\") {\n      const isCustom = key.charCodeAt(1) === 45;\n      string +=\n        (isCustom ? key : cssCase(key)) +\n        \":\" +\n        (typeof value !== \"number\" ||\n        unitless[key as keyof typeof unitless] ||\n        value === 0 ||\n        isCustom\n          ? value\n          : value + \"px\") +\n        \";\";\n    } else {\n      string += key + \"{\" + stringifyStyleObject(value as StyleObject) + \"}\";\n    }\n  }\n\n  return string;\n}\n\nfunction compileLiterals(args: IArguments): string {\n  const literals = args[0];\n  return Array.isArray(literals)\n    ? literals.reduce((curr, next, i) => curr + next + (args[i + 1] || \"\"), \"\")\n    : literals;\n}\n\n//\n// Variable and theme serialization\nconst cssCaseRe = /[A-Z]|^ms/g;\nconst cssDisallowedRe = /[^\\w-]/g;\n// We cache the case transformations below because the cache\n// will grow to a predictable size and the regex is slowwwww\nconst caseCache: Record<string, string> = {};\nfunction cssCase(string: string): string {\n  return (\n    caseCache[string] ??\n    (caseCache[string] = string.replace(cssCaseRe, \"-$&\").toLowerCase())\n  );\n}\n\nfunction serializeTokens(\n  tokens: Record<string, any>,\n  mangle?: CreateStylesOptions[\"mangleTokens\"],\n  names: string[] = []\n): SerializedTokens {\n  const vars: Record<string, any> = {};\n  let css = \"\";\n\n  for (let key in tokens) {\n    const value = tokens[key];\n\n    if (typeof value === \"object\") {\n      const result = serializeTokens(value, mangle, names.concat(key));\n      vars[key] = result.vars;\n      css += result.css;\n    } else {\n      let name = cssCase(\n        names.length > 0 ? names.join(\"-\") + \"-\" + key : key\n      ).replace(cssDisallowedRe, \"-\");\n      vars[key] =\n        \"var(\" +\n        (name =\n          \"--\" +\n          (mangle === true || (mangle && !mangle[name])\n            ? mangled(name)\n            : name)) +\n        \")\";\n      css += name + \":\" + value + \";\";\n    }\n  }\n\n  return { vars, css };\n}\n\nconst mangled = safeHash(\"\", fnv1aHash);\n\ntype SerializedTokens = {\n  readonly vars: Record<string, Record<string, any> | string | number>;\n  readonly css: string;\n};\n\nfunction mergeTokens<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(\n  target: Record<string, any>,\n  source: Record<string, any>\n): TokensUnion<Tokens, Themes> {\n  for (const key in source) {\n    const value = source[key];\n    target[key] =\n      typeof value === \"object\" ? mergeTokens(target[key] || {}, value) : value;\n  }\n\n  return target as TokensUnion<Tokens, Themes>;\n}\n\n/**\n * A utility function that will convert a camel-cased, dot-notation string\n * into a dash-cased CSS property variable.\n *\n * @param path - A dot-notation string that represents the path to a value\n */\nexport function pathToToken<\n  Tokens extends Record<string, unknown> = TokensUnion<DashTokens, DashThemes>\n>(path: KeysUnion<Tokens>): string {\n  return (\n    \"var(--\" +\n    path.replace(/\\./g, \"-\").replace(cssCaseRe, \"-$&\").toLowerCase() +\n    \")\"\n  );\n}\n\ntype Concat<Fst, Scd> = Fst extends string\n  ? Scd extends string | number\n    ? Fst extends \"\"\n      ? `${Scd}`\n      : `${Fst}.${Scd}`\n    : never\n  : never;\n\ntype KeysUnion<T, Cache extends string = \"\"> = T extends Primitive\n  ? Cache\n  : {\n      [P in keyof T]: Concat<Cache, P> | KeysUnion<T[P], Concat<Cache, P>>;\n    }[keyof T];\n\nexport type TokensUnion<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = Tokens & ValueOf<Themes>;\n\n//\n// Creates and exports default `styles` instance\nexport const styles: Styles<DashTokens, DashThemes> = createStyles();\n\n/**\n * These are CSS variable type definitions that tell functions like\n * style callbacks which tokens are available. They can be defined\n * globally in your application like so:\n *\n * @example\n * declare module 'dash-ui/styles' {\n *   export interface DashTokens {\n *     color: {\n *       red: string\n *     }\n *   }\n * }\n *\n * They can also be created automatically when you use a `createStyles()` factory.\n * @example\n * const styles = createStyles({\n *   tokens: {\n *     foo: 'bar',\n *     bar: 'baz'\n *   }\n * })\n *\n * // \"foo\" | \"bar\"\n * type Level1VariableNames = keyof DashTokens\n */\nexport interface DashTokens extends Record<string, unknown> {}\n\n/**\n * These are CSS variable theme type definitions that tell functions like\n * style callbacks which tokens are available and which themes are available in\n * `styles.theme()`. They can be defined globally in your application like so:\n *\n * @example\n * declare module 'dash-ui/styles' {\n *   export interface DashThemes {\n *     light: {\n *       color: {\n *         red: string;\n *       }\n *     }\n *     dark: {\n *       color: {\n *         red: string;\n *       }\n *     }\n *   }\n * }\n */\nexport interface DashThemes extends Record<string, Record<string, unknown>> {}\n\n/**\n * The names of the themes defined in the `DashThemes` type\n */\nexport type DashThemeNames = Extract<keyof DashThemes, string>;\n"]},"metadata":{},"sourceType":"module"}