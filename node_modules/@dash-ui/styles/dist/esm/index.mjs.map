{"version":3,"file":"index.mjs","sources":["../../src/utils.ts","../../src/create-dash.ts","../../src/create-styles.ts"],"sourcesContent":["/**\n * An FNV-1a hashing algorithm with a 32-bit offset basis. FNV-1a hashes are designed\n * to be fast while maintaining a low collision rate. The high dispersion rate makes\n * them well-suited for hashing nearly identical strings.\n *\n * @param string - A string you want to hash\n */\nexport function hash(string: string): string {\n  // 32-bit offset basis\n  let out = 2166136261;\n  let i = 0;\n  let len = string.length;\n\n  for (; i < len; ++i)\n    out =\n      (out ^= string.charCodeAt(i)) +\n      (out << 1) +\n      (out << 4) +\n      (out << 7) +\n      (out << 8) +\n      (out << 24);\n\n  return (out >>> 0).toString(36);\n}\n\nconst minL = /(^|[:;,{}\\s])\\s+|$/g;\nconst minR = / +{/g;\n\nexport function safeHash(\n  key: string,\n  hashFn: typeof hash\n): (string: string) => string {\n  const hashCache: Record<string, string> = {};\n  let value: string | undefined;\n  return (string: string): string => {\n    if ((value = hashCache[string])) return value;\n    value = hashFn(string.replace(minL, \"$1\").replace(minR, \"{\"));\n    // allows class names to start with numbers\n    return (hashCache[string] = value =\n      !key && !isNaN(value[0] as any) ? \"_\" + value : value);\n  };\n}\n\nexport function noop(): void {}\n","import Stylis from \"@dash-ui/stylis\";\nimport type { Context, Plugable, Plugin } from \"@dash-ui/stylis\";\nimport { noop } from \"./utils\";\n\n/**\n * Dash is a tiny, performant CSS-in-JS style rule sheet manager similar to Emotion.\n *\n * @param options - Configuration options\n */\nexport function createDash(options: CreateDashOptions = {}): Dash {\n  let {\n    key = \"ui\",\n    nonce,\n    speedy,\n    stylisPlugins,\n    prefix = true,\n    container = typeof document !== \"undefined\" ? document.head : void 0,\n  } = options;\n  const stylis = new Stylis({ prefix });\n  speedy =\n    speedy === void 0 || speedy === null\n      ? !(\n          typeof process !== \"undefined\" &&\n          process.env.NODE_ENV !== \"production\"\n        )\n      : speedy;\n  const inserted: Dash[\"inserted\"] = new Set<string>();\n  const cache: Dash[\"cache\"] = new Map();\n  const sheetsCache = new Map<string, DashSheet>();\n  const sheet = styleSheet({\n    key,\n    container,\n    nonce,\n    speedy,\n  });\n\n  if (typeof document !== \"undefined\") {\n    let nodes = document.querySelectorAll('style[data-cache=\"' + key + '\"]');\n    let i = 0;\n    let attr;\n    let node;\n    const insert = inserted.add.bind(inserted);\n\n    for (; i < nodes.length; i++) {\n      /* istanbul ignore next */\n      if ((attr = (node = nodes[i]).getAttribute(`data-dash`)) === null)\n        continue;\n      attr.split(\" \").forEach(insert);\n\n      container && node.parentNode !== container && container.appendChild(node);\n    }\n\n    stylis.use(stylisPlugins)(ruleSheet as Plugin);\n  }\n\n  /* istanbul ignore next */\n  if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n    const commentStart = /\\/\\*/g;\n    const commentEnd = /\\*\\//g;\n\n    stylis.use((context, content) => {\n      if (context === -1) {\n        while (commentStart.test(content)) {\n          commentEnd.lastIndex = commentStart.lastIndex;\n\n          /* istanbul ignore next */\n          if (commentEnd.test(content)) {\n            commentStart.lastIndex = commentEnd.lastIndex;\n            continue;\n          }\n\n          throw new Error(\n            'Your styles have an unterminated comment (\"/*\" without ' +\n              'corresponding \"*/\").'\n          );\n        }\n\n        commentStart.lastIndex = 0;\n      }\n    });\n  }\n\n  let insert: Dash[\"insert\"] = function (key, selector, styles, styleSheet) {\n    if (inserted.has(key)) return;\n    inserted.add(key);\n    Sheet.x = styleSheet === void 0 ? sheet : styleSheet;\n    stylis(selector, styles);\n  };\n\n  if (typeof document === \"undefined\") {\n    insert = function (key, selector, styles, styleSheet) {\n      if (inserted.has(key)) return;\n      inserted.add(key);\n      Sheet.x = styleSheet === void 0 ? sheet : styleSheet;\n      cache.set(key, stylis(selector, styles));\n    };\n  }\n\n  return {\n    key,\n    sheet,\n    sheets: {\n      add(name) {\n        const sheetRef = sheetsCache.get(name) || {\n          n: 0,\n          s: styleSheet(sheet),\n        };\n        sheetsCache.set(name, sheetRef);\n        sheetRef.n++;\n        return sheetRef.s;\n      },\n      delete(name) {\n        const sheetRef = sheetsCache.get(name);\n        if (!sheetRef) return -1;\n        if (sheetRef.n === 1) {\n          sheetsCache.delete(name);\n          sheetRef.s.flush();\n        }\n        return --sheetRef.n;\n      },\n      keys: sheetsCache.keys.bind(sheetsCache),\n    },\n    stylis,\n    insert,\n    inserted,\n    cache,\n  };\n}\n\nexport interface CreateDashOptions {\n  /**\n   * Keys in sheets used to associate `<style>` tags with this\n   * specific `dash` instances via the `dash-cache` property.\n   *\n   * @default \"ui\"\n   */\n  readonly key?: string;\n  /**\n   * For security policies. A nonce is an arbitrary number that can be used just\n   * once in a cryptographic communication.\n   */\n  readonly nonce?: string;\n  /**\n   * An array of stylis plugins\n   * See: https://www.npmjs.com/package/stylis\n   */\n  readonly stylisPlugins?: Plugable[];\n  /**\n   * Turns on/off vendor prefixing. When a boolean, all prefixes will be\n   * turned on/off. Use a function to define your own prefixes for a given key/value.\n   *\n   * @default true\n   */\n  readonly prefix?:\n    | boolean\n    | ((key: string, value: any, context: any) => boolean);\n  /**\n   * This is the container that `<style>` tags will be injected into\n   * when style rules are inserted.\n   *\n   * @default document.head\n   */\n  readonly container?: HTMLElement;\n  /**\n   * Uses speedy mode for `<style>` tag insertion. It's the fastest way\n   * to insert new style rules, but will make styles uneditable in some browsers.\n   *\n   * @default false\n   */\n  readonly speedy?: boolean;\n}\n\nexport type Dash = {\n  /**\n   * The sheet key\n   */\n  readonly key: string;\n  /**\n   * The default style sheet used by this instance of Dash\n   */\n  readonly sheet: DashStyleSheet;\n  /**\n   * Used for tracking external sheets. You can safely add/delete new\n   * custom sheets using this. Those sheets can be used in the `insert()`\n   * method. The primary reason you'd want to use this is so that you can\n   * create independently flushable styles/sheets.\n   */\n  readonly sheets: DashSheets;\n  /**\n   * The instance of Stylis used by this Dash instance\n   */\n  readonly stylis: typeof Stylis;\n  /**\n   * A cache of Stylis rules saved by their keys. This is only used\n   * on the server for generating CSS files and strings from the keys\n   * used in the cache.\n   */\n  readonly cache: Map<string, string>;\n  /**\n   * A function for inserting style rules into the document and cache.\n   *\n   * @param key - The unique key of the rule. This is used for caching.\n   * @param selector - The CSS selector to insert the rule under. Omit this\n   *   when inserting a global style.\n   * @param styles - The rules string you'd like to insert into the document or cache.\n   * @param styleSheet - The style sheet to insert a rule into, for example `dash.sheet`.\n   */\n  insert(\n    key: string,\n    selector: string,\n    styles: string,\n    styleSheet?: DashStyleSheet\n  ): void;\n  /**\n   * An insertion cache. This tracks which keys have already been inserted into\n   * the DOM to prevent duplicates.\n   */\n  readonly inserted: Set<string>;\n};\n\n/**\n * A stylesheet cache that tracks references to the keys in it.\n * When there are no more references to a sheet, it will be flushed\n * from the DOM.\n */\nexport interface DashSheets {\n  /**\n   * Creates a new stylesheet if it doesn't exist and returns it.\n   *\n   * @param key - The unique key of the style sheet\n   */\n  add(key: string): DashStyleSheet;\n  /**\n   * Deletes the stylesheet from the sheets cache and flushes the\n   * `<style>` tag from the DOM if this is is the last reference to\n   * the key.\n   *\n   * @param key - The key to the sheet\n   */\n  delete(key: string): number;\n  /**\n   * Returns an iterator containing all of the keys in the cache.\n   */\n  keys(): ReturnType<Map<string, DashSheet>[\"keys\"]>;\n}\n\ninterface DashSheet {\n  /**\n   * The number of references to the sheet\n   */\n  n: number;\n  /**\n   * A dash style sheet.\n   */\n  s: DashStyleSheet;\n}\n\n//\n// Stylesheet\nexport function styleSheet(options: DashStyleSheetOptions): DashStyleSheet {\n  // Based off emotion and glamor's StyleSheet\n  const { key, container, nonce, speedy = false } = options;\n  const tags: HTMLStyleElement[] = [];\n  let size = 0;\n\n  return {\n    // include all keys so it the object can be cloned via styleSheet(sheet)\n    key,\n    nonce,\n    container,\n    speedy,\n    insert(rule) {\n      // the max length is how many rules we have per style tag, it's 65000 in\n      // speedy mode it's 1 in dev because we insert source maps that map a\n      // single rule to a location and you can only have one source map per\n      // style tag\n      if (size % (speedy ? 65000 : 1) === 0) {\n        const tag = document.createElement(\"style\");\n        tag.setAttribute(`data-dash`, key);\n        if (nonce) tag.setAttribute(\"nonce\", nonce);\n        tag.textContent = \"\";\n        container &&\n          container.insertBefore(\n            tag,\n            !tags.length ? null : tags[tags.length - 1].nextSibling\n          );\n        tags.push(tag);\n      }\n\n      const tag = tags[tags.length - 1];\n\n      if (!speedy) {\n        tag.textContent += rule;\n      } else {\n        let sheet: StyleSheet | CSSStyleSheet | null = tag.sheet;\n        let i = 0;\n        /* istanbul ignore next */\n        if (!sheet) {\n          // this weirdness brought to you by firefox\n          const { styleSheets } = document;\n          for (; i < styleSheets.length; i++)\n            if (styleSheets[i].ownerNode === tag) {\n              sheet = styleSheets[i];\n              break;\n            }\n        }\n\n        /* istanbul ignore next */\n        try {\n          // this is a really hot path\n          // we check the second character first because having \"i\"\n          // as the second character will happen less often than\n          // having \"@\" as the first character\n          const isImportRule =\n            rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64;\n          // this is the ultrafast version, works across browsers\n          // the big drawback is that the css won't be editable in devtools\n          (sheet as CSSStyleSheet).insertRule(\n            rule,\n            // we need to insert @import rules before anything else\n            // otherwise there will be an error\n            // technically this means that the @import rules will\n            // _usually_(not always since there could be multiple style tags)\n            // be the first ones in prod and generally later in dev\n            // this shouldn't really matter in the real world though\n            // @import is generally only used for font faces from google fonts\n            // and etc. so while this could be technically correct then it\n            // would be slower and larger for a tiny bit of correctness that\n            // won't matter in the real world\n            isImportRule ? 0 : (sheet as CSSStyleSheet).cssRules.length\n          );\n        } catch (e) {\n          if (\n            typeof process !== \"undefined\" &&\n            process.env.NODE_ENV !== \"production\"\n          ) {\n            console.warn(\n              'There was a problem inserting the following rule: \"' +\n                rule +\n                '\"',\n              e\n            );\n          }\n        }\n      }\n\n      size++;\n    },\n    flush() {\n      tags.forEach((tag) => (tag.parentNode as HTMLElement).removeChild(tag));\n      tags.length = 0;\n      size = 0;\n    },\n  };\n}\n\nexport interface DashStyleSheetOptions {\n  /**\n   * Keys in sheets used to associate style sheets with\n   * specific `dash` instances\n   */\n  readonly key: string;\n  /**\n   * The element to insert `<style>` tags into. For example,\n   * `document.head`.\n   */\n  readonly container?: HTMLElement;\n  /**\n   * For security policies. A nonce is an arbitrary number that can be used just\n   * once in a cryptographic communication.\n   */\n  readonly nonce?: string;\n  /**\n   * Uses speedy mode for `<style>` tag insertion. It's the fastest way\n   * to insert new style rules, but will make styles uneditable in some browsers.\n   *\n   * @default false\n   */\n  readonly speedy?: boolean;\n}\n\nexport interface DashStyleSheet {\n  /**\n   * The sheet key\n   */\n  readonly key: string;\n  /**\n   * The sheet nonce\n   */\n  readonly nonce?: string;\n  /**\n   * The sheet container\n   */\n  readonly container?: HTMLElement;\n  /**\n   * `true` if speedy mode is turned on\n   */\n  readonly speedy: boolean;\n  /**\n   * Inserts a style rule into your sheet\n   *\n   * @param rule - A style rule to insert into the sheet\n   */\n  insert(rule: string): void;\n  /**\n   * Removes all style rules from the sheet.\n   */\n  flush(): void;\n}\n\n//\n// Stylis plugins\nconst RULE_DELIMITER = \"/*|*/\";\nconst RULE_NEEDLE = RULE_DELIMITER + \"}\";\n\nfunction ruleSheet(\n  // https://github.com/thysultan/stylis.js/tree/master/plugins/rule-sheet\n  context: Context,\n  content: any,\n  selectors: string[],\n  parents: string[],\n  line: number,\n  column: number,\n  length: number,\n  ns: number,\n  depth: number,\n  at: number\n): string | undefined {\n  // property\n  if (context === 1) {\n    if (content.charCodeAt(0) === 64) {\n      // @import\n      Sheet.x.insert(content + \";\");\n      return \"\";\n    }\n  }\n  // selector\n  else if (context === 2) {\n    if (ns === 0) return content + RULE_DELIMITER;\n  }\n  // at-rule\n  else if (context === 3) {\n    // @font-face, @page\n    if (ns === 102 || ns === 112) {\n      Sheet.x.insert(selectors[0] + content);\n      return \"\";\n    } else {\n      /* istanbul ignore next */\n      return content + (at === 0 ? RULE_DELIMITER : \"\");\n    }\n  } else if (context === -2) {\n    content.split(RULE_NEEDLE).forEach((block: string) => {\n      block && Sheet.x.insert(block + \"}\");\n    });\n  }\n}\n\nconst Sheet: {\n  x: {\n    insert(rule: string): void;\n  };\n} = {\n  x: {\n    insert: noop,\n  },\n};\n","import unitless from \"@dash-ui/unitless\";\nimport type {\n  HtmlAttributes as CSSHTMLAttributes,\n  PropertiesFallback as CSSProperties,\n  Pseudos as CSSPseudos,\n  SvgAttributes as CSSSvgAttributes,\n} from \"csstype\";\nimport type { JsonValue, PartialDeep, Primitive, ValueOf } from \"type-fest\";\nimport { createDash } from \"./create-dash\";\nimport type { Dash } from \"./create-dash\";\nimport { hash as fnv1aHash, noop, safeHash } from \"./utils\";\n\n/**\n * A factory function that returns a new `styles` instance with\n * your custom configuration options.\n *\n * @param options - Configuration options\n */\nexport function createStyles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(options: CreateStylesOptions<Tokens, Themes> = {}): Styles<Tokens, Themes> {\n  const dash = options.dash || createDash();\n  const { key, insert, sheets } = dash;\n  const themes = {} as Themes;\n  const tokens = {} as TokensUnion<Tokens, Themes>;\n  const hash = safeHash(key, options.hash || fnv1aHash);\n\n  let label: (args: any[]) => string;\n  // explicit here on purpose so it's not in every test\n  /* istanbul ignore next */\n  if (\n    typeof process !== \"undefined\" &&\n    process.env.NODE_ENV === \"development\"\n  ) {\n    label = function (args) {\n      // add helpful labels to the name in development\n      return [...args]\n        .reduce((curr, arg) => {\n          if (typeof arg === \"string\") {\n            curr += \"-\" + arg;\n          } else if (typeof arg === \"object\") {\n            const keys = Object.keys(arg).filter(\n              (k) => typeof arg[k] === \"number\" || arg[k]\n            );\n\n            if (keys.length) {\n              curr += \"-\" + keys.join(\"-\");\n            }\n          }\n\n          return curr;\n        }, \"\")\n        .replace(/[^\\w-]/g, \"-\");\n    };\n  }\n\n  const styles: Styles<Tokens, Themes> = {\n    variants<Variants extends string | number>(\n      styleMap: StyleMap<Variants, Tokens, Themes>\n    ): Style<Variants, Tokens, Themes> {\n      const compiledStyleMap: Record<string | number, string> = {};\n      let styleKey: keyof typeof styleMap;\n      /* istanbul ignore next */\n      for (styleKey in styleMap)\n        compiledStyleMap[styleKey] = compileStyles(styleMap[styleKey], tokens);\n\n      const defaultStyles = compiledStyleMap.default || \"\";\n\n      // style('text', {})\n      function style(): string {\n        // eslint-disable-next-line prefer-spread\n        const css_ = css.apply(null, arguments as any);\n        if (!css_) return \"\";\n        let name = hash(css_);\n        /* istanbul ignore next */\n        if (label) name += label(arguments as any);\n        const className = key + \"-\" + name;\n        insert(name, \".\" + className, css_);\n        return className;\n      }\n\n      function css(): string {\n        const args = arguments as unknown as StyleArguments<Variants>;\n        const numArgs = args.length;\n\n        if (numArgs === 1 && typeof args[0] !== \"object\") {\n          return defaultStyles + (compiledStyleMap[args[0] as any] || \"\");\n        } else if (numArgs > 0) {\n          let nextStyles = defaultStyles;\n\n          for (let i = 0; i < numArgs; i++) {\n            let arg = args[i];\n            if (typeof arg !== \"object\") {\n              nextStyles += compiledStyleMap[arg as any] || \"\";\n            } else if (arg !== null) {\n              for (const key in arg)\n                if (arg[key]) nextStyles += compiledStyleMap[key] || \"\";\n            }\n          }\n\n          return nextStyles;\n        }\n\n        return defaultStyles;\n      }\n\n      style.styles = styleMap;\n      style.css = css;\n      return style;\n    },\n    one() {\n      const one = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(one);\n      const className = key + \"-\" + name;\n      const callback: StylesOne = function (createClassName) {\n        if (!createClassName && createClassName !== void 0) return \"\";\n        insert(name, \".\" + className, one);\n        return className;\n      };\n      callback.css = function (createCss) {\n        return !createCss && createCss !== void 0 ? \"\" : one;\n      };\n      return callback;\n    },\n    cls() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(css);\n      const className = key + \"-\" + name;\n      insert(name, \".\" + className, css);\n      return className;\n    },\n    lazy<Value extends LazyValue>(\n      lazyFn: (\n        value: Value\n      ) => string | StyleCallback<Tokens, Themes> | StyleObject\n    ): StylesLazy<Value> {\n      const cache = new Map<string | Value, string>();\n\n      function css(value?: Value): string {\n        if (value === void 0) return \"\";\n        const key = typeof value === \"object\" ? JSON.stringify(value) : value;\n        let css = cache.get(key);\n\n        if (css === void 0) {\n          css = compileStyles<Tokens, Themes>(lazyFn(value), tokens);\n          cache.set(key, css);\n        }\n\n        return css;\n      }\n\n      const lazyStyle: StylesLazy<Value> = function (value?: Value) {\n        const css_ = css(value);\n        if (!css_) return \"\";\n        const name = hash(css_);\n        const className = key + \"-\" + name;\n        insert(name, \".\" + className, css_);\n        return className;\n      };\n      lazyStyle.css = css;\n      return lazyStyle;\n    },\n    join() {\n      const css = \"\".concat(...Array.prototype.slice.call(arguments));\n      const name = hash(css);\n      const className = key + \"-\" + name;\n      insert(name, \".\" + className, css);\n      return className;\n    },\n    keyframes() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n      const name = hash(css);\n      const animationName = key + \"-\" + name;\n      // Adding to a cached sheet here rather than the default sheet because\n      // we want this to persist between `clearCache()` calls.\n      insert(\n        name,\n        \"\",\n        \"@keyframes \" + animationName + \"{\" + css + \"}\",\n        sheets.add(name)\n      );\n      return animationName;\n    },\n    insertGlobal() {\n      const css = compileStyles<Tokens, Themes>(\n        compileLiterals(arguments),\n        tokens\n      );\n\n      if (!css) return noop;\n      const name = hash(css);\n      insert(name, \"\", css, sheets.add(name));\n      return function () {\n        !sheets.delete(name) && dash.inserted.delete(name);\n      };\n    },\n    insertTokens(nextTokens, selector = \":root\") {\n      const { css, vars } = serializeTokens(nextTokens, options.mangleTokens);\n      if (!css) return noop;\n      mergeTokens<Tokens, Themes>(tokens, vars);\n      return styles.insertGlobal(selector + \"{\" + css + \"}\");\n    },\n    insertThemes(nextThemes) {\n      const flush: (() => void)[] = [];\n\n      for (const name in nextThemes) {\n        flush.push(\n          styles.insertTokens(\n            // God the types here are f'ing stupid. Someone should feel free to fix this.\n            (themes[name as Extract<keyof Themes, string>] =\n              themes[name as Extract<keyof Themes, string>] === void 0\n                ? nextThemes[name]\n                : mergeTokens<any>(\n                    themes[name as Extract<keyof Themes, string>],\n                    nextThemes[name] as any\n                  )),\n            \".\" + styles.theme(name as Extract<keyof Themes, string>)\n          )\n        );\n      }\n\n      return function () {\n        flush.forEach((e) => e());\n      };\n    },\n    theme(theme) {\n      return key + \"-\" + theme + \"-theme\";\n    },\n    dash,\n    hash,\n    tokens,\n  };\n\n  Object.defineProperty(styles, \"tokens\", {\n    get() {\n      return tokens;\n    },\n    configurable: false,\n  });\n  styles.insertTokens(options.tokens || emptyObj);\n  styles.insertThemes(options.themes || emptyObj);\n  return typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\"\n    ? Object.freeze(styles)\n    : styles;\n}\n\nconst emptyObj: any = {};\n\nexport interface CreateStylesOptions<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> {\n  /**\n   * An instance of dash created by the `createDash()` factory\n   *\n   * @default createDash()\n   */\n  dash?: Dash;\n  /**\n   * Inserts CSS tokens into the DOM and makes them available for use in\n   * style callbacks. The name of the CSS tokens is automatically generated\n   * based upon the depth of the mapping i.e. `foo.bar.baz` -> `--foo-bar-baz`.\n   *\n   * @example\n   * const styles = createStyles({\n   *   tokens: {\n   *     color: {\n   *       // var(--color-light-red)\n   *       lightRed: '#c17'\n   *     }\n   *   }\n   * })\n   *\n   * const bgRed = styles.one(({color}) => ({\n   *   backgroundColor: color.lightRed\n   * }))\n   *\n   * const Component = () => <div className={bgRed()} />\n   */\n  readonly tokens?: Tokens;\n  /**\n   * A mapping of theme name/CSS variable pairs.\n   *\n   * This Creates a CSS variable-based theme by defining tokens within a\n   * class name selector matching the theme name. Apart from that it works\n   * the same way `tokens` does.\n   *\n   * @example\n   * const styles = createStyles({\n   *   themes: {\n   *     // .ui-light\n   *     light: {\n   *       // var(--background-color)\n   *       backgroundColor: '#fff'\n   *     },\n   *     // .ui-dark\n   *     dark: {\n   *       // var(--background-color)\n   *       backgroundColor: '#000'\n   *     }\n   *   }\n   * })\n   *\n   * // CSS tokens in the 'dark' theme take precedence in this component\n   * const App = () => <div className={styles.theme('dark)}/>\n   */\n  readonly themes?: Themes;\n  /**\n   * When `true` this will mangle CSS variable names. You can also\n   * provide an object with `{key: boolean}` pairs of reserved keys\n   * which will not be mangled.\n   *\n   * @example\n   * const styles = createStyles({\n   *   // All CSS tokens will be mangled in production\n   *   mangleTokens: process.env.NODE_ENV === 'production'\n   * })\n   * @example\n   * const styles = createStyles({\n   *   mangleTokens: {\n   *     // --vh will not be mangled\n   *     vh: true\n   *   }\n   * })\n   */\n  readonly mangleTokens?: boolean | Record<string, boolean>;\n  /**\n   * Use your own hash function for creating selector names. By default\n   * Dash uses an fnv1a hashing algorithm.\n   */\n  readonly hash?: typeof fnv1aHash;\n}\n\n/**\n * Utility methods that accomplish everything you need to scale an application\n * using CSS-in-JS.\n */\nexport interface Styles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> {\n  /**\n   * `styles.variants()` is a function for composing styles in a\n   * deterministic way. It returns a function which when called will insert\n   * your styles into the DOM and create a unique class name.\n   *\n   * @param styleMap - A style name/value mapping\n   * @example\n   * const bg = styles({\n   *   // Define styles using an object\n   *   blue: {\n   *     backgroundColor: 'blue'\n   *   },\n   *   // Access stored CSS tokens when a callback is provided as\n   *   // the value\n   *   red: ({colors}) => `\n   *     background-color: ${colors.red};\n   *   `,\n   *   // Define styles using a string\n   *   green: `\n   *     background-color: green;\n   *   `\n   * })\n   *\n   * // This component will have a \"red\" background\n   * const Component = () => <div className={bg('blue', 'red')}/>\n   *\n   * // This component will have a \"blue\" background\n   * const Component = () => <div className={bg('red', 'blue')}/>\n   *\n   * // This component will have a \"green\" background\n   * const Component = () => <div className={bg({red: true, green: true})}/>\n   */\n  variants<Variants extends string | number>(\n    styleMap: StyleMap<Variants, Tokens, Themes>\n  ): Style<Variants, Tokens, Themes>;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback,\n   * and returns a function. That function inserts the style into a `<style>` tag and\n   * returns a class name when called.\n   *\n   * @example\n   * const row = styles.one`\n   *   display: flex;\n   *   flex-wrap: nowrap;\n   * `\n   * const Row = props => <div {...props} className={row()}/>>\n   * // This will not insert the styles if `isRow` is `false`\n   * const RowSometimes = ({isRow = false}) => <div className={row(isRow)}/>>\n   */\n  one(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleObject\n      | StyleCallback<Tokens, Themes>,\n    ...placeholders: string[]\n  ): StylesOne;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Calling this will immediately insert the CSS into the DOM and return a unique\n   * class name for the styles. This is a shortcut for `styles.one('display: flex;')()`.\n   *\n   * @example\n   * const Component = () => <div className={styles.cls`display: flex;`}/>\n   */\n  cls(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleObject\n      | StyleCallback<Tokens, Themes>,\n    ...placeholders: string[]\n  ): string;\n  /**\n   * A function that uses lazy evalution to create styles with indeterminate values.\n   * Calling this will immediately insert the CSS into the DOM and return a unique\n   * class name for the styles.\n   *\n   * @example\n   * const lazyWidth = styles.lazy((width) => ({\n   *   width\n   * }))\n   * const Component = ({width = 200}) => <div className={lazyWidth(width)}/>>\n   */\n  lazy<Value extends LazyValue>(\n    lazyFn: (\n      value: Value\n    ) => string | StyleCallback<Tokens, Themes> | StyleObject\n  ): StylesLazy<Value>;\n  /**\n   * A function that joins CSS strings, inserts them into the DOM right away, and returns a class name.\n   *\n   * @example\n   * const Component = () => <div\n   *   className={styles.join(\n   *     button.css('primary'),\n   *     transition.css('fade'),\n   *     'display: block;'\n   *   )}\n   * />\n   */\n  join(...css: string[]): string;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Using this will immediately insert a global `@keyframes` defintion into the DOM and\n   * return the name of the keyframes instance.\n   *\n   * @example\n   * const fadeIn = styles.keyframes`\n   *   from {\n   *     opacity: 0;\n   *   }\n   *\n   *   to {\n   *     opactity: 1\n   *   }\n   * `\n   */\n  keyframes(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleCallback<Tokens, Themes>\n      | StyleObject,\n    ...placeholders: string[]\n  ): string;\n  /**\n   * A function that returns the generated class name for a given theme when\n   * using `insertThemes()` to create CSS variable-based themes.\n   *\n   * @param name - The name of the theme\n   * @example\n   * styles.insertThemes({\n   *  dark: {\n   *    color: {\n   *      background: '#000'\n   *    }\n   *  }\n   * })\n   *\n   * const Component = () => <div className={styles.theme('dark')}/>\n   */\n  theme(name: keyof Themes): string;\n  /**\n   * Inserts CSS tokens into the DOM and makes them available for use in\n   * style callbacks. The name of the CSS tokens is automatically generated\n   * based upon the depth of the mapping i.e. `foo.bar.baz` -> `--foo-bar-baz`.\n   * This function returns a function that will flush the styles inserted by\n   * `insertTokens()` when it is called.\n   *\n   * @param tokens - A map of CSS variable name/value pairs\n   * @param selector - Including a selector will only make these CSS variable\n   *   definitions take effect within the selector, e.g. a class name or ID. By\n   *   default the selector is `\":root\"`.\n   * @example\n   * // Inserts CSS tokens into the document `:root`\n   * styles.insertTokens({\n   *   color: {\n   *     // var(--color-indigo)\n   *     indigo: '#5c6ac4',\n   *     // var(--color-blue)\n   *     blue: '#007ace',\n   *     // var(--color-red)\n   *     red: '#de3618',\n   *   }\n   * })\n   *\n   * // Overrides the above when they are used within a `.dark` selector\n   * const flushTokens = styles.insertTokens(\n   *   {\n   *     color: {\n   *       // var(--color-indigo)\n   *       indigo: '#5c6ac4',\n   *       // var(--color-blue)\n   *       blue: '#007ace',\n   *       // var(--color-red)\n   *       red: '#de3618',\n   *     }\n   *   },\n   *   '.dark'\n   * )\n   */\n  insertTokens(tokens: PartialDeep<Tokens>, selector?: string): () => void;\n  /**\n   * Creates a CSS variable-based theme by defining tokens within a\n   * class name selector matching the theme name. Apart from that it works\n   * the same way `insertTokens()` does. This function returns a function\n   * that will flush the styles inserted by `insertTokens()` when it is called.\n   *\n   * @param themes - A mapping of theme name/CSS variable pairs.\n   * @example\n   * const flushThemes = styles.insertThemes({\n   *   // .ui-light\n   *   light: {\n   *     // var(--background-color)\n   *     backgroundColor: '#fff'\n   *   },\n   *   // .ui-dark\n   *   dark: {\n   *     // var(--background-color)\n   *     backgroundColor: '#000'\n   *   }\n   * })\n   *\n   * // \"dark\" css tokens will take precedence within this component\n   * const Component = () => <div className={styles.theme('dark)}/>\n   */\n  insertThemes(\n    themes: PartialDeep<{\n      [Name in keyof Themes]: Themes[Name];\n    }>\n  ): () => void;\n  /**\n   * A function that accepts a tagged template literal, style object, or style callback.\n   * Using this will immediately insert styles into the DOM relative to the root document.\n   * This function returns a function that will flush the styles inserted by\n   * `insertGlobal()` when it is called.\n   *\n   * @example\n   * const flushGlobal = styles.insertGlobal(({color}) => `\n   *   body {\n   *     background-color: ${color.primaryBg};\n   *   }\n   * `)\n   */\n  insertGlobal(\n    literals:\n      | TemplateStringsArray\n      | string\n      | StyleCallback<Tokens, Themes>\n      | StyleObject,\n    ...placeholders: string[]\n  ): () => void;\n  /**\n   * The CSS tokens currently defined in the instance\n   */\n  tokens: TokensUnion<Tokens, Themes>;\n  /**\n   * A hashing function for creating unique selector names\n   *\n   * @param string - The string you'd like to hash\n   */\n  hash(string: string): string;\n  /**\n   * The instance of underlying the Dash cache used by this instance. This was\n   * automatically created by `createDash()` when `createStyles()` was called.\n   * Dash controls the caching, style sheets, auto-prefixing, and DOM insertion\n   * that happens in the `styles` instance.\n   */\n  dash: Dash;\n}\n\n/**\n * A function that inserts styles from the style map into the DOM when called\n * with those style names selected.\n *\n * @param args - A series of style names or style name/boolean maps which\n *  select the styles from the style map you want to compose into a singular\n *  deterministic style and class name.\n * @example\n * const style = styles.variants({\n *   block: 'display: block',\n *   w100: 'width: 100px;',\n *   h100: 'height: 100px',\n * })\n *\n * // display: block; height: 100px; width: 100px;\n * const Component = () => <div className={style('block', 'h100', 'w100')}/>\n */\nexport type Style<\n  Variants extends string | number,\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = {\n  (...args: StyleArguments<Variants>): string;\n  /**\n   * A function that returns the raw, CSS string for a given\n   * name in the style map.\n   *\n   * @param names - A series of style names or style name/boolean maps which\n   *  select the styles from the style map you want to compose into a singular\n   *  CSS string.\n   * @example\n   * const style = styles.variants({\n   *   block: 'display: block',\n   *   w100: 'width: 100px;',\n   *   h100: 'height: 100px',\n   * })\n   *\n   * const someOtherStyle = styles.variants({\n   *   // display: block; height: 100px; width: 100px;\n   *   default: style.css('block', 'h100', 'w100')\n   * })\n   */\n  css(...names: StyleArguments<Variants>): string;\n  /**\n   * The style map that this `style()` instance was instantiated with.\n   */\n  styles: StyleMap<Variants, Tokens, Themes>;\n};\n\n/**\n * A function that inserts styles into the DOM when called without\n * a falsy value. If the first argument is falsy, the styles will\n * not be inserted and a class name will not be returned.\n */\nexport type StylesOne = {\n  (createClassName?: boolean | number | string | null): string;\n  /**\n   * A method that returns a CSS string if the first argument is not falsy.\n   */\n  css(createCss?: boolean | number | string | null): string;\n};\n\nexport type StyleMap<\n  Variants extends string | number,\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = {\n  [Name in Variants | \"default\"]?: StyleValue<Tokens, Themes>;\n};\n\nexport type StyleArguments<Variants extends string | number> = (\n  | Variants\n  | {\n      [Name in Variants]?: boolean | null | undefined | string | number;\n    }\n  | Exclude<Falsy, 0 | \"\">\n)[];\n\nexport type StyleValue<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = string | StyleCallback<Tokens, Themes> | StyleObject;\n\ntype KnownStyles = {\n  [property in keyof CSSProperties]?:\n    | CSSProperties[property]\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | (string & {})\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | (number & {});\n};\n\ntype PseudoStyles = {\n  [property in CSSPseudos | CSSHTMLAttributes | CSSSvgAttributes]?: StyleObject;\n};\n\ntype SelectorStyles = {\n  [property: string]:\n    | string\n    | number\n    | KnownStyles\n    | PseudoStyles\n    | SelectorStyles;\n};\n\nexport type StyleObject = KnownStyles & PseudoStyles & SelectorStyles;\n\nexport type StyleCallback<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = (tokens: TokensUnion<Tokens, Themes>) => StyleObject | string;\n\nexport type LazyValue = JsonValue;\n\n/**\n * A function that inserts indeterminate styles based on the value\n * into the DOM when called.\n *\n * @param value - A JSON serializable value to create indeterminate\n *   styles from\n */\nexport type StylesLazy<Value extends LazyValue> = {\n  (value?: Value): string;\n  /**\n   * A method that returns indeterminate CSS strings based on the value\n   * when called.\n   *\n   * @param value - A JSON serializable value to create indeterminate\n   *   styles from\n   */\n  css(value?: Value): string;\n};\n\n//\n// Utils\nexport type Falsy = false | null | undefined | \"\" | 0;\n\n/**\n * A utility function that will compile style objects and callbacks into CSS strings.\n *\n * @param styles - A style callback, object, or string\n * @param tokens - A map of CSS tokens for style callbacks\n */\nexport function compileStyles<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(\n  styles: StyleValue<Tokens, Themes> | Falsy,\n  tokens: TokensUnion<Tokens, Themes>\n): string {\n  const value = typeof styles === \"function\" ? styles(tokens) : styles;\n  return typeof value === \"object\" && value !== null\n    ? stringifyStyleObject(value)\n    : // TypeScript w/o \"strict\": true throws here\n      ((value || \"\") as string);\n}\n\nfunction stringifyStyleObject(object: StyleObject): string {\n  let string = \"\";\n\n  for (const key in object) {\n    const value = object[key];\n\n    if (typeof value !== \"object\") {\n      const isCustom = key.charCodeAt(1) === 45;\n      string +=\n        (isCustom ? key : cssCase(key)) +\n        \":\" +\n        (typeof value !== \"number\" ||\n        unitless[key as keyof typeof unitless] ||\n        value === 0 ||\n        isCustom\n          ? value\n          : value + \"px\") +\n        \";\";\n    } else {\n      string += key + \"{\" + stringifyStyleObject(value as StyleObject) + \"}\";\n    }\n  }\n\n  return string;\n}\n\nfunction compileLiterals(args: IArguments): string {\n  const literals = args[0];\n  return Array.isArray(literals)\n    ? literals.reduce((curr, next, i) => curr + next + (args[i + 1] || \"\"), \"\")\n    : literals;\n}\n\n//\n// Variable and theme serialization\nconst cssCaseRe = /[A-Z]|^ms/g;\nconst cssDisallowedRe = /[^\\w-]/g;\n// We cache the case transformations below because the cache\n// will grow to a predictable size and the regex is slowwwww\nconst caseCache: Record<string, string> = {};\nfunction cssCase(string: string): string {\n  return (\n    caseCache[string] ??\n    (caseCache[string] = string.replace(cssCaseRe, \"-$&\").toLowerCase())\n  );\n}\n\nfunction serializeTokens(\n  tokens: Record<string, any>,\n  mangle?: CreateStylesOptions[\"mangleTokens\"],\n  names: string[] = []\n): SerializedTokens {\n  const vars: Record<string, any> = {};\n  let css = \"\";\n\n  for (let key in tokens) {\n    const value = tokens[key];\n\n    if (typeof value === \"object\") {\n      const result = serializeTokens(value, mangle, names.concat(key));\n      vars[key] = result.vars;\n      css += result.css;\n    } else {\n      let name = cssCase(\n        names.length > 0 ? names.join(\"-\") + \"-\" + key : key\n      ).replace(cssDisallowedRe, \"-\");\n      vars[key] =\n        \"var(\" +\n        (name =\n          \"--\" +\n          (mangle === true || (mangle && !mangle[name])\n            ? mangled(name)\n            : name)) +\n        \")\";\n      css += name + \":\" + value + \";\";\n    }\n  }\n\n  return { vars, css };\n}\n\nconst mangled = safeHash(\"\", fnv1aHash);\n\ntype SerializedTokens = {\n  readonly vars: Record<string, Record<string, any> | string | number>;\n  readonly css: string;\n};\n\nfunction mergeTokens<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n>(\n  target: Record<string, any>,\n  source: Record<string, any>\n): TokensUnion<Tokens, Themes> {\n  for (const key in source) {\n    const value = source[key];\n    target[key] =\n      typeof value === \"object\" ? mergeTokens(target[key] || {}, value) : value;\n  }\n\n  return target as TokensUnion<Tokens, Themes>;\n}\n\n/**\n * A utility function that will convert a camel-cased, dot-notation string\n * into a dash-cased CSS property variable.\n *\n * @param path - A dot-notation string that represents the path to a value\n */\nexport function pathToToken<\n  Tokens extends Record<string, unknown> = TokensUnion<DashTokens, DashThemes>\n>(path: KeysUnion<Tokens>): string {\n  return (\n    \"var(--\" +\n    path.replace(/\\./g, \"-\").replace(cssCaseRe, \"-$&\").toLowerCase() +\n    \")\"\n  );\n}\n\ntype Concat<Fst, Scd> = Fst extends string\n  ? Scd extends string | number\n    ? Fst extends \"\"\n      ? `${Scd}`\n      : `${Fst}.${Scd}`\n    : never\n  : never;\n\ntype KeysUnion<T, Cache extends string = \"\"> = T extends Primitive\n  ? Cache\n  : {\n      [P in keyof T]: Concat<Cache, P> | KeysUnion<T[P], Concat<Cache, P>>;\n    }[keyof T];\n\nexport type TokensUnion<\n  Tokens extends DashTokens = DashTokens,\n  Themes extends DashThemes = DashThemes\n> = Tokens & ValueOf<Themes>;\n\n//\n// Creates and exports default `styles` instance\nexport const styles: Styles<DashTokens, DashThemes> = createStyles();\n\n/**\n * These are CSS variable type definitions that tell functions like\n * style callbacks which tokens are available. They can be defined\n * globally in your application like so:\n *\n * @example\n * declare module '＠dash-ui/styles' {\n *   export interface DashTokens {\n *     color: {\n *       red: string\n *     }\n *   }\n * }\n *\n * They can also be created automatically when you use a `createStyles()` factory.\n * @example\n * const styles = createStyles({\n *   tokens: {\n *     foo: 'bar',\n *     bar: 'baz'\n *   }\n * })\n *\n * // \"foo\" | \"bar\"\n * type Level1VariableNames = keyof DashTokens\n */\nexport interface DashTokens extends Record<string, unknown> {}\n\n/**\n * These are CSS variable theme type definitions that tell functions like\n * style callbacks which tokens are available and which themes are available in\n * `styles.theme()`. They can be defined globally in your application like so:\n *\n * @example\n * declare module '＠dash-ui/styles' {\n *   export interface DashThemes {\n *     light: {\n *       color: {\n *         red: string;\n *       }\n *     }\n *     dark: {\n *       color: {\n *         red: string;\n *       }\n *     }\n *   }\n * }\n */\nexport interface DashThemes extends Record<string, Record<string, unknown>> {}\n\n/**\n * The names of the themes defined in the `DashThemes` type\n */\nexport type DashThemeNames = Extract<keyof DashThemes, string>;\n"],"names":["hash","string","out","i","len","length","charCodeAt","toString","safeHash","key","hashFn","value","hashCache","replace","minL","minR","isNaN","noop","createDash","options","nonce","speedy","stylisPlugins","prefix","container","document","head","stylis","Stylis","inserted","Set","cache","Map","sheetsCache","sheet","styleSheet","attr","node","nodes","querySelectorAll","insert","add","bind","getAttribute","split","forEach","parentNode","appendChild","use","ruleSheet","selector","styles","has","Sheet","x","set","sheets","name","sheetRef","get","n","s","delete","flush","keys","tag","removeChild","tags","size","rule","createElement","setAttribute","textContent","insertBefore","nextSibling","push","styleSheets","ownerNode","isImportRule","insertRule","cssRules","e","block","context","content","selectors","parents","line","column","ns","depth","at","RULE_DELIMITER","createStyles","dash","themes","tokens","fnv1aHash","variants","styleMap","style","css_","css","apply","arguments","className","args","numArgs","defaultStyles","compiledStyleMap","nextStyles","arg","styleKey","compileStyles","default","one","compileLiterals","callback","createClassName","createCss","cls","lazy","lazyFn","JSON","stringify","lazyStyle","join","concat","Array","prototype","slice","call","keyframes","animationName","insertGlobal","insertTokens","nextTokens","vars","serializeTokens","mangle","names","result","cssCase","cssDisallowedRe","mangled","mangleTokens","mergeTokens","insertThemes","nextThemes","theme","Object","defineProperty","configurable","emptyObj","stringifyStyleObject","object","isCustom","unitless","literals","isArray","reduce","curr","next","caseCache","cssCaseRe","toLowerCase","target","source","pathToToken","path"],"mappings":"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"}