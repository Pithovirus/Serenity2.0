import Stylis from "@dash-ui/stylis";
import { noop } from "./utils";
/**
 * Dash is a tiny, performant CSS-in-JS style rule sheet manager similar to Emotion.
 *
 * @param options - Configuration options
 */

export function createDash(options) {
  if (options === void 0) {
    options = {};
  }

  let {
    key = "ui",
    nonce,
    speedy,
    stylisPlugins,
    prefix = true,
    container = typeof document !== "undefined" ? document.head : void 0
  } = options;
  const stylis = new Stylis({
    prefix
  });
  speedy = speedy === void 0 || speedy === null ? !(typeof process !== "undefined" && process.env.NODE_ENV !== "production") : speedy;
  const inserted = new Set();
  const cache = new Map();
  const sheetsCache = new Map();
  const sheet = styleSheet({
    key,
    container,
    nonce,
    speedy
  });

  if (typeof document !== "undefined") {
    let nodes = document.querySelectorAll('style[data-cache="' + key + '"]');
    let i = 0;
    let attr;
    let node;
    const insert = inserted.add.bind(inserted);

    for (; i < nodes.length; i++) {
      /* istanbul ignore next */
      if ((attr = (node = nodes[i]).getAttribute(`data-dash`)) === null) continue;
      attr.split(" ").forEach(insert);
      container && node.parentNode !== container && container.appendChild(node);
    }

    stylis.use(stylisPlugins)(ruleSheet);
  }
  /* istanbul ignore next */


  if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
    const commentStart = /\/\*/g;
    const commentEnd = /\*\//g;
    stylis.use((context, content) => {
      if (context === -1) {
        while (commentStart.test(content)) {
          commentEnd.lastIndex = commentStart.lastIndex;
          /* istanbul ignore next */

          if (commentEnd.test(content)) {
            commentStart.lastIndex = commentEnd.lastIndex;
            continue;
          }

          throw new Error('Your styles have an unterminated comment ("/*" without ' + 'corresponding "*/").');
        }

        commentStart.lastIndex = 0;
      }
    });
  }

  let insert = function (key, selector, styles, styleSheet) {
    if (inserted.has(key)) return;
    inserted.add(key);
    Sheet.x = styleSheet === void 0 ? sheet : styleSheet;
    stylis(selector, styles);
  };

  function _ref(key, selector, styles, styleSheet) {
    if (inserted.has(key)) return;
    inserted.add(key);
    Sheet.x = styleSheet === void 0 ? sheet : styleSheet;
    cache.set(key, stylis(selector, styles));
  }

  if (typeof document === "undefined") {
    insert = _ref;
  }

  return {
    key,
    sheet,
    sheets: {
      add(name) {
        const sheetRef = sheetsCache.get(name) || {
          n: 0,
          s: styleSheet(sheet)
        };
        sheetsCache.set(name, sheetRef);
        sheetRef.n++;
        return sheetRef.s;
      },

      delete(name) {
        const sheetRef = sheetsCache.get(name);
        if (!sheetRef) return -1;

        if (sheetRef.n === 1) {
          sheetsCache.delete(name);
          sheetRef.s.flush();
        }

        return --sheetRef.n;
      },

      keys: sheetsCache.keys.bind(sheetsCache)
    },
    stylis,
    insert,
    inserted,
    cache
  };
}

function _ref2(tag) {
  return tag.parentNode.removeChild(tag);
}

//
// Stylesheet
export function styleSheet(options) {
  // Based off emotion and glamor's StyleSheet
  const {
    key,
    container,
    nonce,
    speedy = false
  } = options;
  const tags = [];
  let size = 0;
  return {
    // include all keys so it the object can be cloned via styleSheet(sheet)
    key,
    nonce,
    container,
    speedy,

    insert(rule) {
      // the max length is how many rules we have per style tag, it's 65000 in
      // speedy mode it's 1 in dev because we insert source maps that map a
      // single rule to a location and you can only have one source map per
      // style tag
      if (size % (speedy ? 65000 : 1) === 0) {
        const tag = document.createElement("style");
        tag.setAttribute(`data-dash`, key);
        if (nonce) tag.setAttribute("nonce", nonce);
        tag.textContent = "";
        container && container.insertBefore(tag, !tags.length ? null : tags[tags.length - 1].nextSibling);
        tags.push(tag);
      }

      const tag = tags[tags.length - 1];

      if (!speedy) {
        tag.textContent += rule;
      } else {
        let sheet = tag.sheet;
        let i = 0;
        /* istanbul ignore next */

        if (!sheet) {
          // this weirdness brought to you by firefox
          const {
            styleSheets
          } = document;

          for (; i < styleSheets.length; i++) if (styleSheets[i].ownerNode === tag) {
            sheet = styleSheets[i];
            break;
          }
        }
        /* istanbul ignore next */


        try {
          // this is a really hot path
          // we check the second character first because having "i"
          // as the second character will happen less often than
          // having "@" as the first character
          const isImportRule = rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64; // this is the ultrafast version, works across browsers
          // the big drawback is that the css won't be editable in devtools

          sheet.insertRule(rule, // we need to insert @import rules before anything else
          // otherwise there will be an error
          // technically this means that the @import rules will
          // _usually_(not always since there could be multiple style tags)
          // be the first ones in prod and generally later in dev
          // this shouldn't really matter in the real world though
          // @import is generally only used for font faces from google fonts
          // and etc. so while this could be technically correct then it
          // would be slower and larger for a tiny bit of correctness that
          // won't matter in the real world
          isImportRule ? 0 : sheet.cssRules.length);
        } catch (e) {
          if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
            console.warn('There was a problem inserting the following rule: "' + rule + '"', e);
          }
        }
      }

      size++;
    },

    flush() {
      tags.forEach(_ref2);
      tags.length = 0;
      size = 0;
    }

  };
}
//
// Stylis plugins
const RULE_DELIMITER = "/*|*/";
const RULE_NEEDLE = RULE_DELIMITER + "}";

function _ref3(block) {
  block && Sheet.x.insert(block + "}");
}

function ruleSheet( // https://github.com/thysultan/stylis.js/tree/master/plugins/rule-sheet
context, content, selectors, parents, line, column, length, ns, depth, at) {
  // property
  if (context === 1) {
    if (content.charCodeAt(0) === 64) {
      // @import
      Sheet.x.insert(content + ";");
      return "";
    }
  } // selector
  else if (context === 2) {
    if (ns === 0) return content + RULE_DELIMITER;
  } // at-rule
  else if (context === 3) {
    // @font-face, @page
    if (ns === 102 || ns === 112) {
      Sheet.x.insert(selectors[0] + content);
      return "";
    } else {
      /* istanbul ignore next */
      return content + (at === 0 ? RULE_DELIMITER : "");
    }
  } else if (context === -2) {
    content.split(RULE_NEEDLE).forEach(_ref3);
  }
}

const Sheet = {
  x: {
    insert: noop
  }
};