{"version":3,"file":"index.mjs","sources":["../../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-var-requires */\n\n/**\n * Creates a string of CSS based on the dash `inserted` cache. This\n * is an extremely fast way to generate a CSS string. It returns an\n * object containing the hash names of all of the styles used as well\n * as the CSS string.\n *\n * Note that this function is unsafe in asynchronous render environments\n * because multiple pages using the same cache will dirty the results.\n * This means it will not work with Gatsby, for example.\n *\n * @param styles - A `styles()` instance\n * @param options - Configuration options\n */\nexport function createStylesFromCache(\n  styles = require(\"@dash-ui/styles\").styles,\n  options: CreateServerStylesOptions = {}\n): ServerStylesResult {\n  const { clearCache = false } = options;\n  const { dash } = styles;\n  const styleCache = dash.cache;\n  const names = new Set([...dash.sheets.keys(), ...dash.inserted.values()]);\n  let css = \"\";\n\n  for (const name of names) css += styleCache.get(name);\n\n  if (clearCache) dash.inserted.clear();\n  return { names: [...names], css };\n}\n\n/**\n * Creates a `<style>` tag w/ CSS based on the dash `inserted` cache. This\n * is an extremely fast way to generate a `<style>` tag.\n *\n * Note that this function is unsafe in asynchronous render environments\n * because multiple pages using the same cache will dirty the results.\n * This means it will not work with Gatsby, for example.\n *\n * @param styles - A `styles()` instance\n * @param options - Configuration options\n */\nexport function createStyleTagFromCache(\n  styles = require(\"@dash-ui/styles\").styles,\n  options: CreateServerStylesOptions = {}\n): string {\n  const { css, names } = createStylesFromCache(styles, options);\n  const nonceString = styles.dash.sheet.nonce\n    ? ` nonce=\"${styles.dash.sheet.nonce}\"`\n    : \"\";\n\n  return `<style data-dash=\"${names.join(\" \")}\" data-cache=\"${\n    styles.dash.key\n  }\"${nonceString}>${css}</style>`;\n}\n\n/**\n * Writes a CSS to a file based on the dash `inserted` cache. This\n * is an extremely fast way to generate a CSS file.\n *\n * Note that this function is unsafe in asynchronous render environments\n * because multiple pages using the same cache will dirty the results.\n * This means it will not work with Gatsby, for example.\n *\n * @param outputPath - An absolute or relative path dictating where you want to\n *  output the CSS file.\n * @param styles - A `styles()` instance\n * @param options - Configuration options\n */\nexport async function writeStylesFromCache(\n  outputPath = \"\",\n  styles = require(\"@dash-ui/styles\").styles,\n  options?: WriteServerStylesOptions & { clearCache?: boolean }\n): Promise<WriteServerStylesResult> {\n  // Requiring in here prevents webpack errors in stuff like Next.js apps\n  const fs = require(\"fs\");\n  const path = require(\"path\");\n  let { name, hash = styles.hash, clearCache = false } = options || {};\n  const { css, names } = createStylesFromCache(styles, { clearCache });\n  name = `${name || styles.dash.key + \"-\" + hash(css) + \".css\"}`;\n  const filename = path.join(outputPath, name);\n  await fs.promises.writeFile(filename, css);\n  return { filename, name, path: outputPath, css, names };\n}\n\n/**\n * Creates a string of CSS based on an HTML string. This function will\n * parse your HTML output for Dash class names and pull the styles associated\n * with them from the Dash cache. It returns an object containing the hash names\n * of all of the styles used as well as the CSS string.\n *\n * This is a safe way to generate style strings in an asynchronous environment\n *\n * @param html - An HTML string\n * @param styles - A `styles()` instance\n */\nexport function createStylesFromString(\n  html: string,\n  styles = require(\"@dash-ui/styles\").styles\n): ServerStylesResult {\n  const { dash } = styles;\n  const styleCache = dash.cache;\n  const names = new Set<string>(dash.sheets.keys());\n\n  let css = \"\";\n  for (let name of names) css += styleCache.get(name);\n\n  const re = new RegExp(`[\"\\\\s'=]${dash.key}-(\\\\w+)`, \"g\");\n  for (const [, name] of html.matchAll(re)) {\n    if (!names.has(name)) {\n      css += styleCache.get(name) || \"\";\n      names.add(name);\n    }\n  }\n\n  return { names: [...names], css };\n}\n\n/**\n * Creates a `<style>` tag w/ CSS based on an HTML string. This function will\n * parse your HTML output for Dash class names and pull the styles associated\n * with them from the Dash cache.\n *\n * This is a safe way to generate `<style>` tags in an asynchronous environment.\n *\n * @param html - An HTML string\n * @param styles - A `styles()` instance\n */\nexport function createStyleTagFromString(\n  html: string,\n  styles = require(\"@dash-ui/styles\").styles\n): string {\n  const { css, names } = createStylesFromString(html, styles);\n  const nonceString = styles.dash.sheet.nonce\n    ? ` nonce=\"${styles.dash.sheet.nonce}\"`\n    : \"\";\n\n  return `<style data-dash=\"${names.join(\" \")}\" data-cache=\"${\n    styles.dash.key\n  }\"${nonceString}>${css}</style>`;\n}\n\n/**\n * Writes a CSS to a file based on an HTML string. This function will\n * parse your HTML output for Dash class names and pull the styles associated\n * with them from the Dash cache.\n *\n * This is a safe way to generate `<style>` tags in an asynchronous environment.\n *\n * @param html\n * @param styles - A `styles()` instance\n * @param outputPath - An absolute or relative path dictating where you want to\n *  output the CSS file.\n * @param options - Configuration options\n */\nexport async function writeStylesFromString(\n  html: string,\n  outputPath = \"\",\n  styles = require(\"@dash-ui/styles\").styles,\n  options?: WriteServerStylesOptions\n): Promise<WriteServerStylesResult> {\n  // Requiring in here prevents webpack errors in stuff like Next.js apps\n  const fs = require(\"fs\");\n  const path = require(\"path\");\n  let { name, hash = styles.hash } = options || {};\n  const { css, names } = createStylesFromString(html, styles);\n  name = `${name || styles.dash.key + \"-\" + hash(css) + \".css\"}`;\n  const filename = path.join(outputPath, name);\n  await fs.promises.writeFile(filename, css);\n  return { filename, name, path: outputPath, css, names };\n}\n\nexport interface ServerStylesResult {\n  /**\n   * A CSS string containing all of the styles that were used\n   */\n  css: string;\n  /**\n   * Hash names of all of the styles used in the generated CSS\n   */\n  names: string[];\n}\n\nexport interface CreateServerStylesOptions {\n  /**\n   * Clears the Dash `inserted` cache after styles have been\n   * generated. This is useful in synchronous environments when you\n   * only want to generate CSS strings for the styles that were actually\n   * used in a given page/render.\n   *\n   * @default false\n   */\n  clearCache?: boolean;\n}\n\nexport interface WriteServerStylesOptions {\n  /**\n   * Use this if you want to create your own name for the CSS file.\n   * By default, this function will create a filename based on the hash\n   * of the generated CSS string.\n   */\n  name?: string;\n  /**\n   * Use a custom hash function for creating the name of your CSS file.\n   * By default this function will use the hash function attached to your\n   * `styles()` instance.\n   */\n  hash?: (string: string) => string;\n}\n\nexport interface WriteServerStylesResult {\n  /**\n   * The filename of the generated file. This is the `outputPath` joined\n   * to the basename of the CSS file that was generated.\n   */\n  filename: string;\n  /**\n   * The basename of the CSS file that was generated.\n   */\n  name: string;\n  /**\n   * The output path of the CSS file excluding the basename.\n   */\n  path: string;\n  /**\n   * The CSS string that was generated and written to the output\n   * file.\n   */\n  css: string;\n  /**\n   * The hash names of all of the styles that were inserted into\n   * the generated CSS string.\n   */\n  names: string[];\n}\n"],"names":["createStylesFromCache","styles","options","require","clearCache","dash","styleCache","cache","names","Set","sheets","keys","inserted","values","css","name","get","clear","createStyleTagFromCache","nonceString","sheet","nonce","join","key","writeStylesFromCache","outputPath","fs","path","hash","filename","promises","writeFile","createStylesFromString","html","re","RegExp","matchAll","has","add","createStyleTagFromString","writeStylesFromString"],"mappings":"4TAeO,SAASA,EACdC,EACAC,YADAD,IAAAA,EAASE,QAAQ,mBAAmBF,iBACpCC,IAAAA,EAAqC,QAE/BE,WAAEA,EAAa,GAAUF,GACzBG,KAAEA,GAASJ,EACXK,EAAaD,EAAKE,MAClBC,EAAQ,IAAIC,IAAI,IAAIJ,EAAKK,OAAOC,UAAWN,EAAKO,SAASC,WAC3DC,EAAM,OAEL,IAAMC,KAAQP,EAAOM,GAAOR,EAAWU,IAAID,UAE5CX,GAAYC,EAAKO,SAASK,QACvB,CAAET,MAAO,IAAIA,GAAQM,IAAAA,GAcvB,SAASI,EACdjB,EACAC,YADAD,IAAAA,EAASE,QAAQ,mBAAmBF,iBACpCC,IAAAA,EAAqC,QAE/BY,IAAEA,EAAFN,MAAOA,GAAUR,EAAsBC,EAAQC,GAC/CiB,EAAclB,EAAOI,KAAKe,MAAMC,iBACvBpB,EAAOI,KAAKe,MAAMC,UAC7B,8BAEwBb,EAAMc,KAAK,sBACrCrB,EAAOI,KAAKkB,QACVJ,MAAeL,sBAgBCU,wCAAf,WACLC,EACAxB,EACAC,YAFAuB,IAAAA,EAAa,aACbxB,IAAAA,EAASE,QAAQ,mBAAmBF,YAI9ByB,EAAKvB,QAAQ,MACbwB,EAAOxB,QAAQ,SACjBY,KAAEA,EAAFa,KAAQA,EAAO3B,EAAO2B,KAAtBxB,WAA4BA,EAAa,GAAUF,GAAW,IAC5DY,IAAEA,EAAFN,MAAOA,GAAUR,EAAsBC,EAAQ,CAAEG,WAAAA,IACvDW,MAAUA,GAAQd,EAAOI,KAAKkB,IAAM,IAAMK,EAAKd,GAAO,YAChDe,EAAWF,EAAKL,KAAKG,EAAYV,gBACjCW,EAAGI,SAASC,UAAUF,EAAUf,GAC/B,CAAEe,SAAAA,EAAUd,KAAAA,EAAMY,KAAMF,EAAYX,IAAAA,EAAKN,MAAAA,qDAc3C,SAASwB,EACdC,EACAhC,YAAAA,IAAAA,EAASE,QAAQ,mBAAmBF,YAE9BI,KAAEA,GAASJ,EACXK,EAAaD,EAAKE,MAClBC,EAAQ,IAAIC,IAAYJ,EAAKK,OAAOC,QAEtCG,EAAM,OACL,IAAIC,KAAQP,EAAOM,GAAOR,EAAWU,IAAID,OAExCmB,EAAK,IAAIC,mBAAkB9B,EAAKkB,cAAc,SAC/C,KAASR,KAASkB,EAAKG,SAASF,GAC9B1B,EAAM6B,IAAItB,KACbD,GAAOR,EAAWU,IAAID,IAAS,GAC/BP,EAAM8B,IAAIvB,UAIP,CAAEP,MAAO,IAAIA,GAAQM,IAAAA,GAavB,SAASyB,EACdN,EACAhC,YAAAA,IAAAA,EAASE,QAAQ,mBAAmBF,YAE9Ba,IAAEA,EAAFN,MAAOA,GAAUwB,EAAuBC,EAAMhC,GAC9CkB,EAAclB,EAAOI,KAAKe,MAAMC,iBACvBpB,EAAOI,KAAKe,MAAMC,UAC7B,8BAEwBb,EAAMc,KAAK,sBACrCrB,EAAOI,KAAKkB,QACVJ,MAAeL,sBAgBC0B,0CAAf,WACLP,EACAR,EACAxB,EACAC,YAFAuB,IAAAA,EAAa,aACbxB,IAAAA,EAASE,QAAQ,mBAAmBF,YAI9ByB,EAAKvB,QAAQ,MACbwB,EAAOxB,QAAQ,SACjBY,KAAEA,EAAFa,KAAQA,EAAO3B,EAAO2B,MAAS1B,GAAW,IACxCY,IAAEA,EAAFN,MAAOA,GAAUwB,EAAuBC,EAAMhC,GACpDc,MAAUA,GAAQd,EAAOI,KAAKkB,IAAM,IAAMK,EAAKd,GAAO,YAChDe,EAAWF,EAAKL,KAAKG,EAAYV,gBACjCW,EAAGI,SAASC,UAAUF,EAAUf,GAC/B,CAAEe,SAAAA,EAAUd,KAAAA,EAAMY,KAAMF,EAAYX,IAAAA,EAAKN,MAAAA"}